{"componentChunkName":"component---src-templates-post-pagination-jsx","path":"/page/5/","result":{"data":{"paging":{"group":[{"fieldValue":"데이터 중심 애플리케이션 설계","totalCount":5}],"nodes":[{"excerpt":"복제 란 네트워크로 연결된 여러 장비에 동일한 데이터 복사본을 유지한다는 의미이다. 데이터 복제가 필요한 이유는 다음과 같다. 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다. 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성을 높인다. 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다. 복제에서 모든 어려움…","html":"<ul>\n<li><strong>복제</strong> 란 네트워크로 연결된 여러 장비에 동일한 데이터 복사본을 유지한다는 의미이다.</li>\n<li>\n<p>데이터 복제가 필요한 이유는 다음과 같다.</p>\n<ul>\n<li>지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다.</li>\n<li>시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성을 높인다.</li>\n<li>읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다.</li>\n</ul>\n</li>\n<li>복제에서 모든 어려움은 복제된 데이터의 변경 처리에 있다.</li>\n<li>\n<p>노드 간 복제를 위한 세 가지 인기 알고리즘이 있다.</p>\n<ul>\n<li><strong>단일 리더 (single-leader)</strong></li>\n<li><strong>다중 리더 (multi-leader)</strong></li>\n<li><strong>리더 없는 (leaderless)</strong></li>\n</ul>\n</li>\n</ul>\n<!-- more -->\n<h2 id=\"리더와-팔로워\" style=\"position:relative;\">리더와 팔로워<a href=\"#%EB%A6%AC%EB%8D%94%EC%99%80-%ED%8C%94%EB%A1%9C%EC%9B%8C\" aria-label=\"리더와 팔로워 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>데이터베이스의 복사본을 저장하는 각 노드를 <strong>복제 서버(replica)</strong> 라고 한다.</li>\n<li>모든 복제서버의 동일한 데이터를 유지하기 위해 데이터베이스의 모든 쓰기는 복제 서버에서 처리돼야 한다.</li>\n<li>\n<p>이 문제를 위한 가장 일반적인 해결책은 <code class=\"language-text\">리더 기반 복제(마스터 슬레이브 복제</code>)이다. 동작은 다음과 같다.</p>\n<ul>\n<li>클라이언트가 데이터베이스에 쓰기를 할 때 요청을 리더에게 보내야 한다.</li>\n<li>리더는 먼저 로컬 저장소에 새로운 데이터를 기록한다.</li>\n<li>리더가 로컬 저장소에 새로운 데이터를 기록할 때마다 데이터 변경을 복제 로그나 변경 스트림의 일부로 팔로워에게 전송한다.</li>\n<li>각 팔로워가 리더로부터 로그를 받으면 리더가 처리한 것과 동일한 순서로 모든 쓰기를 적용해 그에 맞게 데이터베이스의 로컬 복사본을 갱신한다.</li>\n<li><strong>클라이언트가 데이터베이스로부터 읽기를 할 때는 리더 또는 팔로워에게 질의할 수 있지만, 쓰기는 리더에게만 허용된다.</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"동기식-대-비동기식-복제\" style=\"position:relative;\">동기식 대 비동기식 복제<a href=\"#%EB%8F%99%EA%B8%B0%EC%8B%9D-%EB%8C%80-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%8B%9D-%EB%B3%B5%EC%A0%9C\" aria-label=\"동기식 대 비동기식 복제 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>복제 시스템의 중요한 세부 사항은 복제가 <strong>동기식</strong>으로 발생하는지 <strong>비동기식</strong>으로 발생하는지 여부이다.</li>\n<li><code class=\"language-text\">팔로워 1</code>의 복제는 동기식 복제이다. 리더는 <code class=\"language-text\">팔로워 1</code>이 쓰기를 수신했느지 확인해 줄 때까지 기다린다.</li>\n<li><code class=\"language-text\">팔로워 2</code>의 복제는 비동기식이다. 리더는 메시지를 전송하지만 팔로워의 응답을 기다리지 않는다.</li>\n<li>동기식 복제의 장점은 팔로워가 리더와 일관성 있게 최신 데이터 복사본을 가지는 것을 보장한다.</li>\n<li>단점은 팔로워가 죽거나 다른 어떤 이유로 인해 동기 팔로워가 응답하지 않으면 쓰기가 처리될 수 없다는 뜻이다.</li>\n<li>현실적으로 데이터베이스에서 동기식 복제를 사용하려면 보통 <strong>할로워 하나</strong>는 동기식으로 하고 그 밖에는 비동기식으로 하는 것을 의미한다.</li>\n<li>동기식 팔로워가 사용할 수 없게 되거나 느려지면 비동기식 팔로워 중 하나가 동기식이 된다. 이런 설정을 <code class=\"language-text\">반동식(semi-synchronous)</code>이라 한다.</li>\n</ul>\n<h3 id=\"새로운-팔로워-설정\" style=\"position:relative;\">새로운 팔로워 설정<a href=\"#%EC%83%88%EB%A1%9C%EC%9A%B4-%ED%8C%94%EB%A1%9C%EC%9B%8C-%EC%84%A4%EC%A0%95\" aria-label=\"새로운 팔로워 설정 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>때대로 복제 서버수를 늘리거나 장애 노드의 대체를 위해 새로운 팔로워를 설정해야 한다.</li>\n<li>클라이언트는 지속적으로 데이터베이스에 기록하고 데이터는 항상 유동적이기 때문에 표준 파일 복사본은 다른 시점에 데이터베이스의 다른 부분을 보게 된다.</li>\n<li>\n<p>다행이 팔로워 설증은 대게 중단시간 없이 수행할 수 있다.</p>\n<ul>\n<li>리더의 데이터베이스 스냅숏을 일정 시점에 가져온다.</li>\n<li>스냅숏을 새로운 노드에 복사한다.</li>\n<li>팔로워는 리더에 연결해 스냅숏 이후 발생한 모든 데이터 변경을 요청한다. 이것은 스냅숏이 리더의 복제 로그의 정확한 위치와 연관돼야 한다. 이 위치의 명칭을 MySQL 에서는 <code class=\"language-text\">이진로그 좌표(binlog coordinate)</code> 라 부른다.</li>\n<li>팔로워가 스냅숏 이후 데이터 변경의 미처리분을 모두처리했을 때 따라잡았다고 한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"노드-중단-처리\" style=\"position:relative;\">노드 중단 처리<a href=\"#%EB%85%B8%EB%93%9C-%EC%A4%91%EB%8B%A8-%EC%B2%98%EB%A6%AC\" aria-label=\"노드 중단 처리 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<h4>팔로워 장애: 따라잡기 복구</h4>\n<ul>\n<li>각 팔로워는 리더로부터 수신한 데이터 변경 로그를 로컬 디스크에 보관한다.</li>\n<li>\n<p>팔로워가 죽어 재시작하거나 리더와 팔로워 사이의 네트워크가 일시적으로 중단된다면 로그를 통해 쉽게 복구 할 수 있다.</p>\n<ul>\n<li>먼저 보관된 로그에서 결함이 발생하기 전에 처리한 마지막 트랜잭션을 알아낸다.</li>\n<li>트랜잭션 이후 팔로워 연결이 끊어진 동안 발생한 데이터 변경을 모두 요청한다.</li>\n</ul>\n</li>\n</ul>\n<h4>리더 장애: 장애 복구</h4>\n<ul>\n<li>\n<p>팔로워 중 하나를 새로운 리더로 변경해야 하고 클라이언트는 새로운 리더로 쓰기를 전송하기 위해 재설정이 필요하며 다른 팔로워는 새로운 리더로부터 데이터 변경을 소비하기 시작해야 한다. 이 과정을 <strong>장애 복구(failover)</strong> 라 한다.</p>\n<ul>\n<li><strong>리더가 장애인지 판단한다.</strong> 대부분의 시스템은 타임아웃을 사용해 노드가 죽은 것으로 판단한다.</li>\n<li><strong>새로운 리더를 선택한다.</strong> 이전에 선출된 제어 노드(controller node)에 의해 새로운 리더가 임명될 수 있다. 보통 리더의 최신 데이터 변경사항을 가진 복제 서버가 된다.</li>\n<li><strong>새로운 리더 사용을 위해 시스템을 재설정한다.</strong> 이전 리더가 팔로워가 되고 새로운 리더를 인식할 수 있게끔 해야 한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"복제-로그-구현\" style=\"position:relative;\">복제 로그 구현<a href=\"#%EB%B3%B5%EC%A0%9C-%EB%A1%9C%EA%B7%B8-%EA%B5%AC%ED%98%84\" aria-label=\"복제 로그 구현 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<h4>구문 기반 복제 (Statement-Based Replication)</h4>\n<ul>\n<li>리더는 모든 쓰기 요청을 기록하고 쓰기를 실행한 다음 구문 로그를 팔로워에게 전송한다.</li>\n<li>관계형 데이터베이스는 모든 INSERT, UPDATE, DELETE 구문을 팔로워에게 전달하고 각 팔로워는 클라이언트에서 직접 받은 것처럼 SQL 구문을 파싱하고 실행한다.</li>\n<li>\n<p>이 접근법은 복제가 깨질 수 있는 사례가 있다.</p>\n<ul>\n<li><code class=\"language-text\">NOW(), RAND()</code> 같은 비결정적 함수를 호출하는 모든 구문은 각 복제 서버마다 다른 값을 생성할 수 있다.</li>\n<li>자동증가 컬럼을 사용하는 구문이나 데이터베이스에 있는 데이터에 의존한다면 각 복제서버에서 정확히 같은 순서로 실행돼야 한다. 그렇지 않으면 효과가 달라질 수 있다.</li>\n<li>부수 효과를 가진 구문<code class=\"language-text\">(트리거, 스토어드 프로시저, 사용자 정의 함수)</code>은  부수 효과가 완벽하게 결정적이지 않으면 각 복제 서버에서 다른 부수 효과가 발생할 수 있다.</li>\n</ul>\n</li>\n<li>해결책으로 리더는 구문을 기록할 때 모든 비결정적 함수 호출을 고정 값을 반환하게끔 대체할 수 있다.</li>\n</ul>\n<aside>\n💡 MySQL 5.1 이전 버전에서 구문 기반 복제가 사용되고 구문에 비결정성이 있다면 로구 기반 복제(row-based replication)으로 변경한다.\n</aside>\n<h4>쓰기 전 로그 배송</h4>\n<ul>\n<li>일반적으로 모든 쓰기는 로그에 기록된다.</li>\n<li>리더는 디스크에 로그를 기록하는 일 외에도 팔로워에게 네트워크로 로그를 전송하기도 한다.</li>\n<li>팔로워가 이 로그를 처리하면 리더에서 있는 것과 정확히 동일한 데이터 구조의 복제본이 만들어진다.</li>\n<li>\n<p>이 복제 방식의 가장 큰 단점은 로그가 제일 저수준의 데이터를 기술한다는 점이다.</p>\n<ul>\n<li>쓰기 전 로그(WAL)은 어떤 디스크 블록에서 어떤 바이트를 변경했는지와 같은 상세 정보를 포함한다.</li>\n<li>이렇게 하면 복제가 저장소 엔진과 밀접하게 엮이는 문제가 발생한다.</li>\n</ul>\n</li>\n</ul>\n<h4>로우 기반 로그 복제</h4>\n<ul>\n<li>복제 로그를 저장소 엔진 내부와 분리하기 위한 대안으로 복제와 저장소 엔진을 위해 다른 로그 형식을 사용하는 것이다.</li>\n<li>\n<p>이 같은 종류의 복제 로그를 저장소 엔진의 물리적 데이터 표현과 구별하기 위해 논리적 로그라고 부른다.</p>\n<ul>\n<li>삽입된 로우의 로그는 모든 칼럼의 새로운 값을 포함한다.</li>\n<li>삭제된 로우의 로그는 로우를 고유하게 식별하는 데 필요한 정보를 포함한다.</li>\n<li>갱신된 로우의 로그는 로우를 고유하게 식별하는데 필요한 정보와 모든 칼럼의 새로운 값을 포함한다.</li>\n</ul>\n</li>\n<li>여러 로우를 수정하는 트랜잭션은 여러 로그 레코드를 생성한 다음 트랙잭션이 커밋됐음을 레코드에 표시한다.</li>\n<li>논리적 로그는 저장소 엔진 내부와 분리했기 때문에 하위 호환성을 더 쉽게 유지할 수 있고 다른 버전의 데이터베이스 소프트웨어나 심지어 다른 저장소 엔진을 실행할 수 있다.</li>\n<li>논리적 로그 형식은 외부 애플리케이션에서 파싱하기 더 쉽다. 색이이나 캐시 구축을 위해 데이터 웨어하우스 같은 외부 시스템에 데이터베이스의 내용을 전송하고자 할 때 유용하다. 이 기술을 <code class=\"language-text\">변경 데이터 캡처(chage data capture)</code>라 부른다.</li>\n</ul>\n<h4>트리거 기반 복제</h4>\n<ul>\n<li>지금까지 설명한 복제 접근 방식은 애플리케이션 코드의 사용 없이 데이터베이스 시스템에 의해 구현된다.</li>\n<li>데이터의 서브셋만 복제하거나 데이터베이스를 다른 종류의 DB로 복제해야 하거나 충돌 해소 로직이 필요하다면 복제를 애플리케이션 층으로 옮겨야 한다.</li>\n<li>트리거난 데이터 변경을 분리된 테이블에 로깅할 수 있는 기회를 가진다.</li>\n<li>이 테이블로부터 데이터 변경을 외부 프로세스가 읽고 필요한 애플리케이션 로직을 적용해 다른 시스템으로 데이터 변경을 복제한다.</li>\n<li>이 방식은 데이터베이스에 내장된 복제보다 버그나 제한 사항이 더 많이 발생하지만 유연성 때문에 유용하다.</li>\n</ul>\n<h2 id=\"복제-지연-문제\" style=\"position:relative;\">복제 지연 문제<a href=\"#%EB%B3%B5%EC%A0%9C-%EC%A7%80%EC%97%B0-%EB%AC%B8%EC%A0%9C\" aria-label=\"복제 지연 문제 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>복제는 내결합성에만 필요한 것이 아니라 확장서으 지연시간 등의 이유로 필요할 수 있다.</li>\n<li>리더 기반 복제는 모든 쓰기가 단일 노드를 거쳐야 하고 읽기 전용 질의는 어떤 복제 서버에서도 가능하다.</li>\n<li>애플리케이션이  비동기 팔로워에서 데이터를 읽을 때 팔로워가 뒤처진다면 지난 정보를 볼 수 도 있다.</li>\n<li>하지만 데이터베이스에 쓰기를 멈추고 잠시 동안 기다린다면 팔로워는 결국 리더와 일치하게 되는데 이런 효과를 <strong>최종적 일관성</strong>이라고 한다.</li>\n<li>애플리케이션에서 지연이 크면 불일치 문제가 발생할 수 있고 해결 방법을 간략히 설명한다.</li>\n</ul>\n<h3 id=\"자신이-쓴-내용-읽기\" style=\"position:relative;\">자신이 쓴 내용 읽기<a href=\"#%EC%9E%90%EC%8B%A0%EC%9D%B4-%EC%93%B4-%EB%82%B4%EC%9A%A9-%EC%9D%BD%EA%B8%B0\" aria-label=\"자신이 쓴 내용 읽기 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>비동기식 복제 방식에서 문제는 사용자가 쓰기를 수행한 직후 데이터를 본다면 새로운 데이터가 복제 서버에 반영되지 않아 사용자가 제출한 데이터가 유실된 것 처럼 보일 수 있다.</li>\n<li>이런 상황에서는 <code class=\"language-text\">쓰기 후 읽기 일관성</code>이 필요하다. 이것은 사용자가 페이지를 재로딩했을 때 항상 자신이 제출한 모든 갱신을 볼 수 있음을 보장하며 다른 사용자에 대해서는 보장하지 않는다.</li>\n<li>\n<p>쓰기 후 읽기 일관성을 구현하는 방법은 다음과 같다.</p>\n<ul>\n<li>\n<p>사용자가 수정한 내용을 읽을 때는 리더에서 읽고 그 밖에는 팔로워에서 읽는다.</p>\n<ul>\n<li>실제로 질의하지 않고 무엇이 수정됐는지 알 수 있는 방법이 필요하다.</li>\n<li>예를 들어 SNS에서 항상 사용자 소유의 프로필은 리더에서 읽고 다른 사용자의 프로필은 팔로워에서 읽는 간단한 규칙을 사용한다.</li>\n<li>애플리케이션 내 대부분의 내용을 사용자가 편집할 가능성이 있다면 이 접근 방식은 효율적이지 않다.</li>\n<li>이런 경우에는 마지막 생신 시각을 찾아서 특정 시간동안은 리더에서 모든 읽기를 수행하도록 한다.</li>\n<li>또한 팔로워에서 복제 지연을 모니터링해 리더보다 특정 시간 이상 늦은 모든 팔로워에 대한 질의를 금지할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>클라이언트가 가장 최그 쓰기의 타임스탬프를 기억할 수 있다.</p>\n<ul>\n<li>시스템 사용자 읽기를 위한 복제 서버가 최소한 해당 타임스탬프까지 갱신을 반영하게 할 수 있다.</li>\n<li>복제 서버가 최신 내용이 아닌 경우에는 다른 복제 서버가 읽기를 처리하거나 복제 서버가 따라잡을 때까지 질의를 대기시킬 수 있다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"단조-읽기\" style=\"position:relative;\">단조 읽기<a href=\"#%EB%8B%A8%EC%A1%B0-%EC%9D%BD%EA%B8%B0\" aria-label=\"단조 읽기 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>비동기식 복제 방식의 두번째 문제로 사용자가 <strong>시간이 거꾸로 흐르는 현상</strong>을 목격할 수 있다는 것이다.</li>\n<li>리더에서 쓰기 한 내용이 팔로워 1,2 에 반영되는 시점에 차이가 생기게 되면 최신 복제 서버를 읽었을 땐 데이터가 반환되지만 아직 쓰기가 반영되지 않은 복제 서버를 읽었을 땐 아무것도 반환되지 않을 수 있다.</li>\n<li><code class=\"language-text\">단조 읽기(monotonic read)</code>는 이런 종류의 이상 현상이 발생하지 않음을 보장한다.</li>\n</ul>\n<h3 id=\"일관된-순서로-읽기\" style=\"position:relative;\">일관된 순서로 읽기<a href=\"#%EC%9D%BC%EA%B4%80%EB%90%9C-%EC%88%9C%EC%84%9C%EB%A1%9C-%EC%9D%BD%EA%B8%B0\" aria-label=\"일관된 순서로 읽기 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>각각의 팔로워의 지연 때문에 일련의 쓰기 순서가 바뀌는 이상 현상이 발생할 수 있다.</li>\n<li>이런 종류의 이상 현상을 방지하려면 <code class=\"language-text\">일관된 순서 읽기(Consistent Prfix Read)</code> 같은 보장이 필요하다.</li>\n<li>일련의 쓰기가 특정 순서로 발생한다면 이 쓰기를 읽는 모든 사용자는 같은 순서로 쓰여진 내용을 보게 됨을 보장한다.</li>\n</ul>\n<h3 id=\"복제-지연을-위한-해결책\" style=\"position:relative;\">복제 지연을 위한 해결책<a href=\"#%EB%B3%B5%EC%A0%9C-%EC%A7%80%EC%97%B0%EC%9D%84-%EC%9C%84%ED%95%9C-%ED%95%B4%EA%B2%B0%EC%B1%85\" aria-label=\"복제 지연을 위한 해결책 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>앞서 설명한 것처럼 애플리케이션이 기본 데이터베이스보다 더 강력한 보장을 제공하는 할 수 있지만 애플리케이션 코드에서 이 문제를 다루기에는 너무 복잡해서 잘못되기 쉽다. <code class=\"language-text\">(ex: 특정 종류의 리더에서 읽기 수행)</code></li>\n<li>트랜잭션은 애플리케이션이 더 단순해지기 위해 데이터베이스가 강력한 보장을 제공하는 방법이다.</li>\n<li>하지만 분산 데이터베이스로 전환하는 과정에서 많은 시스템이 트랜잭션을 포기했다.</li>\n<li>트랜잭션 성능과 가용성 측면에서 너무 비싸고, 확장 가능 시스템에서는 어쩔 수 없이 최종적 일관성을 사용해야 한다는 주장이 있다.</li>\n<li>남은 부분에서는 이 미묘한 차이를 다루고, 여러 대안 메커니즘을 설명한다.</li>\n</ul>\n<h2 id=\"다중-리더-복제\" style=\"position:relative;\">다중 리더 복제<a href=\"#%EB%8B%A4%EC%A4%91-%EB%A6%AC%EB%8D%94-%EB%B3%B5%EC%A0%9C\" aria-label=\"다중 리더 복제 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>단일 리더 복제는 어떤 이유로 리더에 연결할 수 없다면 데이터베이스에 쓰기를 할 수 없다는 단점이 있다.</li>\n<li>리더 기반 복제 모델은 쓰기를 허용하는 노드를 하나 이상 두는 것으로 자연스럽게 확장된다.</li>\n<li>이 방식을 <strong>다중 리더</strong> 설정<code class=\"language-text\">(마스터/마스터)</code>라고 한다.</li>\n</ul>\n<h3 id=\"다중-리더-복제의-사용-사례\" style=\"position:relative;\">다중 리더 복제의 사용 사례<a href=\"#%EB%8B%A4%EC%A4%91-%EB%A6%AC%EB%8D%94-%EB%B3%B5%EC%A0%9C%EC%9D%98-%EC%82%AC%EC%9A%A9-%EC%82%AC%EB%A1%80\" aria-label=\"다중 리더 복제의 사용 사례 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<h4>다중 데이터센터 운영</h4>\n<ul>\n<li>각 데이터센터마다 리더와 팔로워를 가질 수 있다.</li>\n<li>데이터센터 내에는 리더 팔로워 복제를 사용하고 데이터센터 간에는 각 데이터센터의 리더가 다른 데이터센터의 리더에게 변경 사항을 복제한다.</li>\n<li>\n<p>단일 리더 설정과 다중 리더 설정이 다중 데이터센터에서의 비교이다.</p>\n<ul>\n<li>다중 리더 설정에서 모든 쓰기는 로컬 데이터센터에서 처리한 다음 비동기 방식으로 다른 데이터센터에 복제한다. <strong>사용자가 인지하는 성능은 더 좋아진다.</strong></li>\n<li>단일 리더 설정에서는 리더가 있는 데이터센터가 고장 나면 장애 복구를 위해 다른 데이터센터에서 팔로워를 리더로 승진시킨다. 다중 리더 설정에서는 데이터센터가 독립적으로 동작하여 <strong>데이터센터 중단 내성을 가진다.</strong></li>\n<li>단일 리더 설정에서는 데이터센터 내 연결의 쓰기는 동기식이기 때문에 데이터센터 내 연결 문제에 매우 민감하다. 비동기 복제를 사용하는 다중 리더 설정은 네트워크 문제에 보다 잘 견딘다.</li>\n</ul>\n</li>\n<li>\n<p>다중 리더 복제에는 이점이 있지만 큰 단점도 있다.</p>\n<ul>\n<li>동일한 데이터를 다른 두 개의 데이터 센터에서 동시에 변경할 수 있다. 이때 발생하는 쓰기 충돌은 반드시 해걀해야 한다.</li>\n</ul>\n</li>\n</ul>\n<h4>오프라인 작업을 하는 클라이언트</h4>\n<ul>\n<li>다중 리더 복제가 인터넷 연결이 끊어진 동안 애플리케이션이 계속 동작해야 하는 경우다.</li>\n<li>오프라인 상태에서 데이터를 변경하면 디바이스가 다음에 온라인 상태가 됐을 때 서버와 다른 디바이스를 동기화해야 한다.</li>\n<li>이 경우 모든 디바이스에는 리더처럼 동작하는 로컬 데이터베이스가 있다.</li>\n<li>그리고 모든 디바이스 상에서 복제 서버 간 다중 리더 복제를 비동기 방식으로 수행하는 프로세스(동기화)가 있다.</li>\n</ul>\n<h4>협업 편집</h4>\n<ul>\n<li>동시에 여러 사람이 문서를 편집할 수 있는 애플리케이션을 실시간 협업 편집 애플리케이션이라고 한다.</li>\n<li>한 사용자가 문서를 편집할 때 변경 내용을 즉시 로컬 복제 서버에 적용하고 나서 동일한 문서를 편집하는 다른 사용자와 서버에 비동기 방식으로 복제한다.</li>\n<li>편집 충돌이 없음을 보장하려면 애플리케이션은 사용자가 편집하기 전에 문서의 잠금을 얻어야 한다.</li>\n<li>하지만 더 빠른 협업을 위해 변경 단위를 매우 작게(예를 들면 단일 키 입력) 해서 잠금을 피할 수 있다.</li>\n</ul>\n<h3 id=\"쓰기-충돌-다루기\" style=\"position:relative;\">쓰기 충돌 다루기<a href=\"#%EC%93%B0%EA%B8%B0-%EC%B6%A9%EB%8F%8C-%EB%8B%A4%EB%A3%A8%EA%B8%B0\" aria-label=\"쓰기 충돌 다루기 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>다중 리더 복제에서 제일 큰 문제는 쓰기 충돌이 발생한다는 점이다.</li>\n</ul>\n<h4>동기 대 비동기 충돌 감지</h4>\n<ul>\n<li>단일 리더 데이터베이스에서 첫 번째 쓰기가 완료될 때까지 두 번째 쓰기를 차단해 기다리게 하거나 두 번째 쓰기 트랜잭션을 중단해버린다.</li>\n<li>반면 다중 리더 설정에서는 두 쓰기는 모두 성공하며 충돌은 이후 특정 시점에서 비동기로만 감지한다.</li>\n</ul>\n<h4>충돌 회피</h4>\n<ul>\n<li>충돌을 처리하는 제일 간단한 전략은 충돌을 피하는 것이다.</li>\n<li>특정 레코드의 모든 쓰기가 동일한 리더를 거치도록 애플리케이션이 보장한다면 충돌은 발생하지 않는다.</li>\n<li>예를 들어 애플리케이션에서 특정 사용자의 요청을 동일한 데이터센터로 항상 라우팅하고 데이터센터 내 리더를 사용해 읽기와 쓰기를 하게끔 보장할 수 있다.</li>\n<li>한 사용자 관점에서보면 구성은 기본적으로 단일 리더이다.</li>\n</ul>\n<h4>일관된 상태 수렴</h4>\n<ul>\n<li>다중 리더 설정에서는 쓰기 순서가 정해지지 않아 최종 값이 무엇인지 명확하지 않다.</li>\n<li>단순하게 각 복제 서버가 쓰기를 본 순서대로 적용한다면 데이터베이스의 일관성은 없는 상태가 된다.</li>\n<li>\n<p>충돌을 해소하는 방법은 다양하다.</p>\n<ul>\n<li>각 쓰기에 고유 ID(타임스탬프, UUID 등)을 부여하고 가장 높은 ID를 가진 쓰기를 고른다.</li>\n<li>각 복제 서버에 고유 ID를 부여하고 높은 숫자의 복제 서버에서 생신 쓰기가 낮은 숫자의 복제 서벙서 생신 쓰기보다 항상 우선적으로 적용되게 한다.</li>\n<li>어떻게든 값을 병합한다. (예를 들면 사전순)</li>\n<li>명시적 데이터 구조에 충돌을 기록해 모든 정보를 기록한다. 나중에 충돌을 해소하는 애플리케이션 코드를 작성한다.</li>\n</ul>\n</li>\n</ul>\n<h4>사용자 정의 충돌 해소 로직</h4>\n<ul>\n<li>충돌을 해소하는 가장 적합한 방법은 애플리케이션에 따라 다르다.</li>\n<li>\n<p>대부분의 다중 리더 복제 도구는 애플리케이션 코드를 사용해 충돌 해소 로직을 작성한다.</p>\n<ul>\n<li>\n<p>쓰기 수행 중</p>\n<ul>\n<li>복제된 변경 사항 로그에서 데이터베이스 시스템이 충돌을 감지하자마자 충돌 핸들러를 호출한다.</li>\n</ul>\n</li>\n<li>\n<p>읽기 수행 중</p>\n<ul>\n<li>충돌을 감지하면 모든 충돌 쓰기를 저장한다.</li>\n<li>다음 번 데이터를 읽을 때 이런 여러 버전의 데이터가 애플리케이션에 반환된다.</li>\n<li>애플리케이션은 사용자에게 충돌 내용을 보여주거나 자동으로 충돌을 해소할 수 있다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"다중-리더-복제-토폴리지\" style=\"position:relative;\">다중 리더 복제 토폴리지<a href=\"#%EB%8B%A4%EC%A4%91-%EB%A6%AC%EB%8D%94-%EB%B3%B5%EC%A0%9C-%ED%86%A0%ED%8F%B4%EB%A6%AC%EC%A7%80\" aria-label=\"다중 리더 복제 토폴리지 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>복제 토폴리지는 쓰기를 한 도느에서 다른 노드로 전달하는 통신 경로를 설명한다.</li>\n<li>\n<p>리더가 둘 이상이라면 다양한 토폴로지 구성이 가능하다.</p>\n<ul>\n<li>\n<p><strong>전체 연결(all-to-all)</strong></p>\n<ul>\n<li>모든 리더가 각자의 쓰기를 다른 모든 리더에게 전송한다.</li>\n</ul>\n</li>\n<li>\n<p><strong>원형 토폴리지(circular topology)</strong></p>\n<ul>\n<li>각 노드가 한의 노드로부터 쓰기르 받고, 이 쓰기를 다른 한 노드에 전달한다.</li>\n</ul>\n</li>\n<li>\n<p><strong>별 모양 토폴로지</strong></p>\n<ul>\n<li>지정된 로트 노드 하나가 다른 모든 노드에 쓰기를 전달한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>원형과 별 모양 토폴리지의 문제점은 하나의 노드에 장애가 발생하면 장애가 다른 노드 간 복제 메시지 흐름에 방해를 준다.</li>\n<li>전체 연결 토폴로지는 여러 경로를 따라 이동할 수 있으며 단일 장애점을 피할 수 있기 때문에 내결함성이 좋다.</li>\n<li>하지만 일부 네트워크 연결이 다른 연결보다 빠르면 일부 복제 메시지가 다른 메시지를 추월하여 잘못된 순서로 메시지가 도착할 수 있다.</li>\n</ul>\n<h2 id=\"리더-없는-복제\" style=\"position:relative;\">리더 없는 복제<a href=\"#%EB%A6%AC%EB%8D%94-%EC%97%86%EB%8A%94-%EB%B3%B5%EC%A0%9C\" aria-label=\"리더 없는 복제 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>일부 데이터 저장소 시스템은 리더의 개념을 버리고 모든 복제 서버가 클라이언트부터 쓰기를 직접 받을 수 있게 허용하는 접근 방식을 사용하기도 한다.</li>\n<li>리악, 카산드라, 볼드모트는 리더 없는 복제 모델의 오픈 소스 데이터스토어이고, 이런 종류의 데이터베이스를 다이나모 스타일이라고 한다.</li>\n</ul>\n<h3 id=\"노드가-다운됐을-때-데이터베이스에-쓰기\" style=\"position:relative;\">노드가 다운됐을 때 데이터베이스에 쓰기<a href=\"#%EB%85%B8%EB%93%9C%EA%B0%80-%EB%8B%A4%EC%9A%B4%EB%90%90%EC%9D%84-%EB%95%8C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%97%90-%EC%93%B0%EA%B8%B0\" aria-label=\"노드가 다운됐을 때 데이터베이스에 쓰기 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>\n<p>세 개의 복제 서버를 가진 데이터베이스가 있고 복제 서버 중 하나를 사용할 수 없다고 가정하자.</p>\n<ul>\n<li>클라이언트가 쓰기를 세 개의 모든 복제 서버에 병렬로 전송한다.</li>\n<li>사용 가능한 두 개의 복제 서버는 쓰기를 받았지만 사용 불가능한 복제 서버는 쓰기를 놓쳤다.</li>\n<li>이제  사용할 수 없었던 노드가 온라인 상태가 되고 클라이언트가 이 노드에서 읽기를 시작한다.</li>\n<li>따라서 클라이언트가 해당 노드에서 데이터를 읽는 다면 <code class=\"language-text\">오래된 값</code>을 얻을 수 있다.</li>\n</ul>\n</li>\n</ul>\n<h4>읽기 복구와 안티 엔트로피</h4>\n<ul>\n<li>복제 계획은 최종적으로 모든 데이터가 모든 복제 서버에 복사된 것을 보장해야 한다.</li>\n<li>\n<p>다이나모 스타일 데이터스토어는 다음 두 가지 방법을 주로 사용한다.</p>\n<ul>\n<li>\n<p><strong>읽기 복구</strong></p>\n<ul>\n<li>클라이언트가 여러 노드에서 병렬로 읽기를 수행하면 오래된 응답을 감지할 수 있다.</li>\n<li>클라이언트가 복제 서버에서 응답받은 값이 오래된 값이라는 사실을 알고 해당 복제 서버에 값을 다시 기록한다.</li>\n<li>거의 읽지 않는 값은 일부 복제본에서 누락돼 내구성이 떨어진다.</li>\n</ul>\n</li>\n<li>\n<p><strong>안티 엔트로피 처리</strong></p>\n<ul>\n<li>백그라운드 프로세스를 두고 복제 서버 간 데이터 차이를 지속적으로 찾아 누락된 데이터를 다른 서버로 복사한다.</li>\n<li>리더 기반 복제에서의 로그와 달리 <strong>안티 엔트로피 처리</strong>는 특정 순서로 쓰기를 복사하기 때문에 상당한 지연이 있을 수 있다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4>읽기와 쓰기를 위한 정족수(Quorum)</h4>\n<ul>\n<li>n개의 복제 서버가 있을 때 모든 쓰기는 w개의 노드에서 쓰기가 확정되고 모든 읽기는 최소한 r개의 노드에 질의해야 한다. <code class=\"language-text\">w + r > n</code> 이면 읽을 때 최신 값을 얻는 것으로 기대한다.</li>\n<li>최소한 r개의 노드 중 하나에서 최신 값을 읽을 수 있기 때문이다.</li>\n<li>이런 r 과 w를 따르는 읽기와 쓰기를 정속수(Quorum) 읽기와 쓰기라고 부른다.</li>\n<li>일반적인 선택은 n을 홀수(보통 3,5)로 하고 <code class=\"language-text\">w = r = (n+1) /2 (반올림)</code>로 설정한다.</li>\n<li>쓰기가 적고 읽기가 많은 작업부하는 <code class=\"language-text\">w=n, r= 1</code> 로 설정할 수 있다.</li>\n</ul>\n<h3 id=\"정족수-일관성의-한계\" style=\"position:relative;\">정족수 일관성의 한계<a href=\"#%EC%A0%95%EC%A1%B1%EC%88%98-%EC%9D%BC%EA%B4%80%EC%84%B1%EC%9D%98-%ED%95%9C%EA%B3%84\" aria-label=\"정족수 일관성의 한계 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li><code class=\"language-text\">w + r > n</code> 이 되게끔 w와 r을 선택한다면 일반적으로 모든 읽기는 최신 값을 반환할 것으로 기대한다.</li>\n<li>\n<p>하지만 <code class=\"language-text\">w + r > n</code> 인 경우에도 오래된 값을 반환하는 에지 케이스가 있다.</p>\n<ul>\n<li>두 개의 쓰기가 동시에 발생하면 어떤 쓰기가 먼저 일어났는지 분명하지 않다.</li>\n<li>쓰기와 읽기가 동시에 발생하면 쓰기는 일부 복제 서버에만 반영될 수 있다.</li>\n<li>쓰기가 일부 복제 서버에서는 성공했지만 다른 복제 서버에서 실패해 전체 성공한 서버가 w 복제 서버 보다 적다면 읽기에 해당 쓰기 값이 반환될 수도 있고 아닐 수도 있다.</li>\n<li>새 값을 전달하는 노드가 고장나면 예전 값을 가진 다른 복제 서버에서 해당 데이터가 복원되고 새로운 값을 저장한 복제 서버 수가 w보다 낮아져 정족수 조건이 깨진다.</li>\n</ul>\n</li>\n</ul>\n<h4>최신성 모니터링</h4>\n<ul>\n<li>리더 기반 복제에서 데이터베이스는 복제 지연에 대한 지표를 모니터링 시스템에 제공된다.</li>\n<li>이것은 쓰기가 리더에 적용되고 같은 순서로 팔로워에도 적용되고 각 노드가 복제 로그의 위치를 가지기 때문에 가능하다.</li>\n<li>하지만 리더 없는 복제 시스템에서는 쓰기가 적용된 순서를 고정할 수 없어 모니터링이 더 어렵다.</li>\n<li>최종적 일관성은 의도적으로 모호한 보장이지만 운용성을 위해서는 “최종적을”을 정량화할 수 있어야 한다.</li>\n</ul>\n<h3 id=\"느슨한-정족수와-암시된-핸드오프\" style=\"position:relative;\">느슨한 정족수와 암시된 핸드오프<a href=\"#%EB%8A%90%EC%8A%A8%ED%95%9C-%EC%A0%95%EC%A1%B1%EC%88%98%EC%99%80-%EC%95%94%EC%8B%9C%EB%90%9C-%ED%95%B8%EB%93%9C%EC%98%A4%ED%94%84\" aria-label=\"느슨한 정족수와 암시된 핸드오프 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>쓰기 가용성을 높이기 위해 정족수 w를 만족하지 않아도 일단 연결 할 수 있는 노드에 기록하는 방식을 <code class=\"language-text\">느슨한 정족수</code>라고 부른다.</li>\n<li>네트워크 장애 상황이 해제되면 한 노드가 다른 노드를 위해 일시적으로 수용한 모든 쓰기를 해당 홈 노드로 전송하는 방식을 암시된 핸드오프(hinted handoff)라고 한다.</li>\n<li>느슨한 정족수는 쓰기 가용성을 높이는데 유용하지만 <code class=\"language-text\">w + r > n</code>인 경우에도 키의 최신 값을 읽는다고 보장하지 않는다.</li>\n</ul>\n<h3 id=\"동시-쓰기-감지\" style=\"position:relative;\">동시 쓰기 감지<a href=\"#%EB%8F%99%EC%8B%9C-%EC%93%B0%EA%B8%B0-%EA%B0%90%EC%A7%80\" aria-label=\"동시 쓰기 감지 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>다이나모 스타일 DB에서는 여러 클라이언트가 동시에 같은 키에 쓰는 것을 허용하기 때문에 엄격한 종속수를 사용하더라도 충돌이 발생한다.</li>\n<li><strong>네트워크 지연과 부분적인 장애 때문에 쓰기 요청이 다른 노드에 다른 순서로 도착할 수 있다.</strong></li>\n<li>최종적인 일관성을 달성하기 위해 복제본들은 동일한 값이 돼야 한다.</li>\n</ul>\n<h4>최종 쓰기 승리(Last Write Wins, LWW)</h4>\n<ul>\n<li>각 복제본이 가진 예전 값을 버리고 가장 최신 값으로  덮어쓰는 방법이다.</li>\n<li>클라이언트가 쓰기 요청을 데이터베이스 노드에 전송할 때 다른 클라이언트에 대해서는 아는 것이 없기 때문에 “최신”인지 명확하게 결정하기 어렵다.</li>\n<li>\n<p>그래서 자연적인 순서는 없지만 타임스탬프 같은 임의로 순서를 정할 수 있다.</p>\n<ul>\n<li>LWW라 불리는 충돌 해소 알고리즘은 카산드라에서 유일하게 제공하는 충돌 해소 방법이다.</li>\n</ul>\n</li>\n<li>LWW는 지속성을 희생한다. 동일한 키에 여러 번의 동시 쓰기가 발생하면 쓰기 중 하나만 남고 다른 쓰기는 모두 무시된다.</li>\n</ul>\n<h4>“이전 발생” 관계와 동시성</h4>\n<ul>\n<li>Insert 후 해당 데이터를 Update 하는 작업이 있을 때, Update 하는 작업은 Insert 작업 기반이기 때문에 B 작업은 나중에 발생해야 한다. 이를 B(update)는 A(insert)에 <code class=\"language-text\">인과성이 있다</code>고 한다.</li>\n<li>작업 B가 작업 A에 대해서 알거나 어떤 방식으로든 A에 의존적이라면 작업 A는 작업 B의 <code class=\"language-text\">이전 발생(heppens-befoe</code>이다.</li>\n<li>분산 시스템에서 두 작업이 정확히 같은 시각에 발생했는지 알기란 상당히 어렵다.</li>\n<li>동시성을 정의하기 위해 정확한 시각은 중요하지 않다. 두 작업이 발생한 물리적인 시각보다 각 작업이 서로 알지 못하면 단순히 두 작업은 동시에 수행됐다 말한다.</li>\n</ul>\n<h4>이전 발생 관계 파악하기</h4>\n<ul>\n<li>\n<p>서버는 버전 번호를 보고 두 작업이 동시에 수행됐는지 여부를 결정할 수 있다.</p>\n<ul>\n<li>서버가 모든 키에 대한 버전 정보를 유지하고 키를 기록할 때마다 버전 정보를 증가시킨다.</li>\n<li>클라이언트가 키를 읽을 때는 서버는 최신 버전뿐만 아니라 쓰기 전에 키값도 반환한다.</li>\n<li>클라이언트가 키를 기록할 때는 이전 읽기의 버전 번호를 포함해야하고 이전 읽기에서 받은 모든 값을 함께 합쳐야 한다.</li>\n<li>서버가 특정 버전 번호를 가진 쓰기를 받을 때 해당 버전 이하 모든 값을 덮어 쓸 수 있다. 이보다 높은 버전 번호의 모든 값은 유지해야 한다. 이 값들은 유입된 쓰기와 동시에 발생했기 때문이다.</li>\n</ul>\n</li>\n</ul>\n<h4>동시에 쓴 값 병합</h4>\n<ul>\n<li>여러 작업이 동시에 발생하면 클라이언트는 동시에 쓴 값을 합쳐 정리해야 한다. 이런 동시 값을 <code class=\"language-text\">형제(sibling) 값</code> 이라고 한다.</li>\n<li>간단한 접근 방식으로 버전 번호나 타임스탬프 기반으로 하나의 값을 선택하는 방법(LWW)이 있지만 데이터 손실이 생길 수 있다. 그래서 애플리케이션 코드 내에서 더욱 지능적으로 대처해야 한다.</li>\n</ul>\n<h4>버전 벡터</h4>\n<h2 id=\"정리\" style=\"position:relative;\">정리<a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>\n<p>복제는 다양한 용도로 사용할 수 있다.</p>\n<ul>\n<li>\n<p><strong>고가용성</strong></p>\n<ul>\n<li>한 장비가 다운될 때도 시스템이 계속 동작하게 된다.</li>\n</ul>\n</li>\n<li>\n<p><strong>연결이 끊긴 작업</strong></p>\n<ul>\n<li>네트워크 중단이 있을 때도 애플리케이션이 계속 동작할 수 있게 한다.</li>\n</ul>\n</li>\n<li>\n<p><strong>지연 시간</strong></p>\n<ul>\n<li>지리적으로 사용자에게 가까이 데이터를 배치해 사용자가 더 빠르게 작업할 수 있게 한다.</li>\n</ul>\n</li>\n<li>\n<p><strong>확장성</strong></p>\n<ul>\n<li>복제본에서 읽기를 수행해 단일 장비에서 다룰 수 있는 양보다 많은 양의 읽기 작업을 처리할 수 있다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>복제에 대한 주요 접근 방식</p>\n<ul>\n<li>\n<p><strong>단일 리더 복제</strong></p>\n<ul>\n<li>클라이언트는 모든 쓰기를 단일 리더로 전송하고 리더는 데이터 변경 이벤트 스트림을 다른 복제 서버로 전송한다. 팔로워의 읽기가 오래된 값일 수도 있다.</li>\n<li>이해하기 쉽고 충돌 해소에 대한  우려가 없어서 널리 사용된다.</li>\n</ul>\n</li>\n<li>\n<p><strong>다중 리더 복제</strong></p>\n<ul>\n<li>클라이언트의 각 쓰기가 여러 리더로 전송될 수 있고 각 리더는 다른 리더와 팔로워에게 전송한다.</li>\n</ul>\n</li>\n<li>\n<p><strong>리더 없는 복제</strong></p>\n<ul>\n<li>각 쓰기가 여러 노드로 전송할 수 있고, 클라이언트는 오래된 데이터를 감지하고 이를 바로잡기 위해 병렬로 여러 노드에서 읽는다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>다중 리더 복제나 리더 없는 복제는 노드의 결함, 네트워크 중단, 지연 시간 급증이 있는 상황에서 견고하다. 하지만 어렵고 일관성이 거의 보장되지 않는다는 점이 단점이다.</li>\n<li>\n<p>복제 지연으로 발생할 수 있는 이상 현상들</p>\n<ul>\n<li>\n<p><strong>쓰기 후 읽기 일관성</strong></p>\n<ul>\n<li>사용자는 자신이 제출한 데이터를 항상 볼 수 있어야 한다.</li>\n</ul>\n</li>\n<li>\n<p><strong>단조 읽기</strong></p>\n<ul>\n<li>사용자가 어떤 시점에 데이터를 본 후에는 예전 시점의 데이터는 나중에 볼 수 없다.</li>\n</ul>\n</li>\n<li>\n<p><strong>일관된 순서로 읽기</strong></p>\n<ul>\n<li>사용자는 인과성이 있는 상태의 데이터를 봐야 한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","fields":{"slug":"/ch5/","thumbnail":null},"frontmatter":{"date":"January 23, 2022","update":"Jan 23, 2022","title":"5장 - 복제","description":null,"tags":["데이터 중심 애플리케이션 설계"],"thumbnail":null}},{"excerpt":"데이터 타입이나 스키마가 변경될 때 애플리케이션 코드에 대한 변경이 종종 발생한다. 하지만 대규모 애플리케이션에서 코드 변경은 대게 즉시 반영할 수 없다. 서버 측 애플리케이션에서는 한 번에 몇 개의 노드에 새 버전을 배포하고 새로운 버전이 원할하게 실행되는지 확인한 다음 서서히 모든 노드에서 실행되게 하는 방식이 있다. 클라이언트 측 애플리케이션은 사용…","html":"<ul>\n<li>데이터 타입이나 스키마가 변경될 때 애플리케이션 코드에 대한 변경이 종종 발생한다.</li>\n<li>\n<p>하지만 대규모 애플리케이션에서 코드 변경은 대게 즉시 반영할 수 없다.</p>\n<ul>\n<li>서버 측 애플리케이션에서는 한 번에 몇 개의 노드에 새 버전을 배포하고 새로운 버전이 원할하게 실행되는지 확인한 다음 서서히 모든 노드에서 실행되게 하는 <code class=\"language-text\">순회식 업그레이드(rolling upgrade)</code>방식이 있다.</li>\n<li>클라이언트 측 애플리케이션은 사용자에 전적으로 좌우된다. 어떤 사용자는 한동안 업데이트를 설치하지 않을 수도 있다.</li>\n</ul>\n</li>\n<li>\n<p>이것은 예전 버전의 코드와 새로운 버전의 코드, 이전의 데이터 타입과 새로운 데이터 타입이 모든 시스템에 동시에 공존할 수 있다는 의미이다.</p>\n<ul>\n<li><code class=\"language-text\">하위 호환성 : 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야 한다.</code></li>\n<li><code class=\"language-text\">상위 호환성 : 예전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야 한다.</code></li>\n</ul>\n</li>\n<li>새로운 코드 쓰기는 예전 버전의 코드가 기록한 데이터의 형식을 알기에 명시적으로 해당 형식을 다룰 수 있기 때문에 <code class=\"language-text\">하위 호환성</code>을 일반적으로 어렵지 않다.</li>\n<li><code class=\"language-text\">상위 호환성</code>은 예전 버전의 코드가 새 버전의 코드에 의해 추가된 것을 무시할 수 있어야 하므로 다루기 더 어렵다.</li>\n</ul>\n<!-- more -->\n<h1>데이터 부호화 형식</h1>\n<p>프로그램은 보통 두 가지 형태로 표현된 데이터를 사용한다.</p>\n<ul>\n<li>\n<p>메모리에 객체, 구조체, 리스트, 배열, 해시 테이블, 트리 등으로 데이터를 유지한다.</p>\n<ul>\n<li>이런 데이터 구조는 CPU에서 효율적으로 접근하고 조작할 수 있게 최적화된다.</li>\n</ul>\n</li>\n<li>\n<p>데이터를 파일에 쓰거나 네트워크를 통해 전송하기 위해 바이트열의 형태로 부호화해야 한다.</p>\n<ul>\n<li>일련의 바이트열은 보통 메모리에서 사용하는 데이터 구조와 상당히 다르다.</li>\n</ul>\n</li>\n<li>인메모리 표현에서 바이트열로 전환을 <code class=\"language-text\">부호화(직렬화,마샬링)</code>이라 부른다.</li>\n<li>그 반대를 <code class=\"language-text\">복호화(파싱, 역직렬화, 언마샬링)</code>이라고 한다.</li>\n</ul>\n<h3 id=\"언어별-형식\" style=\"position:relative;\">언어별 형식<a href=\"#%EC%96%B8%EC%96%B4%EB%B3%84-%ED%98%95%EC%8B%9D\" aria-label=\"언어별 형식 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>\n<p>많은 프로그래밍 언어는 인메모리 객체를 바이트열로 부호화하는 기능을 제공한다.</p>\n<ul>\n<li>자바의 Serializable, 루비의 Marshal, 파이썬의 pickle 등</li>\n</ul>\n</li>\n<li>\n<p>프로그래밍 언어에 내장된 부호화 라이브러리는 편리하지만 심각한 문제점 또한 많다.</p>\n<ul>\n<li>부호화는 보통 특정 프로그래밍 언어와 묶여 있어 다른 언어에서 데이터를 읽기 어렵다.</li>\n<li>동일한 객체 유형의 데이터를 복원하려면 복호화 과정이 임의의 클래스를 인스턴스화할 수 있어야 한다. 이것은 종종 보안 문제의 원인이 된다.</li>\n<li>데이터 버전 관리는 보통 나중에 생각하게 된다. 데이터를 빠르고 쉽게 부호화하기 위해 상위, 하위 호환성의 불편한 문제가 등한시되곤 한다.</li>\n<li>자바의 내장 직렬화는 성능이 좋지 않고 비대해지는 부호화로 유명하다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"JSON과-XML-이진-변형\" style=\"position:relative;\">JSON과 XML, 이진 변형<a href=\"#JSON%EA%B3%BC-XML-%EC%9D%B4%EC%A7%84-%EB%B3%80%ED%98%95\" aria-label=\"JSON과 XML 이진 변형 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>수(number)의 부호화에는 많은 애매함이 잇다. XML과 CSV에서 number 와 숫자(digit)로 구성된 문자열을 구분할 수 있다. JSON은 문자열과 수를 구분하지만 정수와 부동소수점 수를 구별하지 않고 정밀도를 지정하지 않는다.</li>\n<li>JSON과 XML은 유니코드(사람이 읽을 수 있는 텍스트)을 잘 지원하지만 이진 문자열을 지원하지 않는다. 이진 데이터를 Base64 텍스트로 부호화해 이런 제한을 피하지만 정공법과는 조금 다르다.</li>\n<li>CSV는 스키마가 없으므로 각 로우와 컬럼의 의미를 정의하는 작업은 애플리케이션이 해야한다.</li>\n</ul>\n<h3 id=\"이진-부호화\" style=\"position:relative;\">이진 부호화<a href=\"#%EC%9D%B4%EC%A7%84-%EB%B6%80%ED%98%B8%ED%99%94\" aria-label=\"이진 부호화 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>JSON과 XML은 이진 형식과 비교하면 둘다 훨씬 많은 공간을 사용한다.</li>\n<li>이런 관찰이 JSON 용으로 사용 가능한 다양한 이진 부호화의 개발로 이어졌지만 JSON과 XML의 텍스트 버전처럼 널리 채택되진 않았다.</li>\n<li>JSON과 XML은 스키마를 사용하지 않기 때문에 부호화된 데이터 안에 모든 객체의 필드 이름을 포함해야 한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token punctuation\">{</span>\n\t<span class=\"token string-property property\">\"userName\"</span> <span class=\"token operator\">:</span> <span class=\"token string\">\"Martin\"</span>\n\t<span class=\"token string-property property\">\"favoriteNumber\"</span> <span class=\"token operator\">:</span> <span class=\"token number\">1337</span><span class=\"token punctuation\">,</span>\n  <span class=\"token string-property property\">\"interests\"</span> <span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span><span class=\"token string\">\"daydreaming\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"hacking\"</span><span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h3 id=\"스리프트와-프로토콜-버퍼\" style=\"position:relative;\">스리프트와 프로토콜 버퍼<a href=\"#%EC%8A%A4%EB%A6%AC%ED%94%84%ED%8A%B8%EC%99%80-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EB%B2%84%ED%8D%BC\" aria-label=\"스리프트와 프로토콜 버퍼 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>스리프트와 프로토콜 버퍼 모두 부호화할 데이터를 위한 스키마가 필요하다.</li>\n<li>프로토콜 버퍼로 정의한 스키마 예</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"jsx\"><pre class=\"language-jsx\"><code class=\"language-jsx\">message Person <span class=\"token punctuation\">{</span>\n\trequired string user_name      <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> # 필드 태그 <span class=\"token number\">1</span>\n\toptional int64 favorite_number <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> # 필드 태그 <span class=\"token number\">2</span>\n\trepeated string interests      <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> # 필드 태그 <span class=\"token number\">3</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>스키마의 <code class=\"language-text\">필드 태그(field tags)</code>를 사용해서 필드 이름의 철자 없이도 어떤 필드를 다루는지 알려줄 수 있다.</li>\n<li>가변 길이 정수(variable-length integer)를 사용해서 더 적은 바이트로 숫자를 부호화할 수 있다.</li>\n</ul>\n<h3 id=\"필드-태그와-스키마의-발전\" style=\"position:relative;\">필드 태그와 스키마의 발전<a href=\"#%ED%95%84%EB%93%9C-%ED%83%9C%EA%B7%B8%EC%99%80-%EC%8A%A4%ED%82%A4%EB%A7%88%EC%9D%98-%EB%B0%9C%EC%A0%84\" aria-label=\"필드 태그와 스키마의 발전 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>스키마는 시간이 지남에 따라 변한다. 이를 <code class=\"language-text\">스키마 발전(schema evolution)</code>이라고 한다.</li>\n<li>각 필드는 태그 숫자(1,2,3)로 식별하고 데이터 타입은 주석으로 단다.</li>\n<li>부호화된 데이터는 필드 이름을 전혀 참조하지 않기 때문에 스키마에서 필디 이름은 변경할 수 있다.</li>\n<li>그러나 필드 태그는 기존의 모든 부호화된 데이터를 인식 불가능하게 만들 수 있기 때문에 변경할 수 없다.</li>\n<li>필드에 새로운 태그 번호를 부여하는 방식으로 스키마에 새로운 필드를 추가할 수 있다. 이는 상위 호환성을 유지하게 한다. <strong>즉 예전 코드가 새로운 코드로 기록된 레코드를 읽을 수 있다.</strong></li>\n<li>새로운 필드를 추가한 경우 이를 optional로 하거나 기본값을 가지게 하여 하위 호환성을 유지할 수 있다.</li>\n</ul>\n<h3 id=\"데이터타입과-스키마-발전\" style=\"position:relative;\">데이터타입과 스키마 발전<a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%83%80%EC%9E%85%EA%B3%BC-%EC%8A%A4%ED%82%A4%EB%A7%88-%EB%B0%9C%EC%A0%84\" aria-label=\"데이터타입과 스키마 발전 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>\n<p>필드의 데이터타입을 변경하는 것은 불가능하지는 않지만 값이 정확하지 않거나 잘릴 위험이 있다.</p>\n<ul>\n<li>예를 들어 32비트 정수를 64비트 정수로 바꾼다고 가정하자.</li>\n<li>파서가 누락된 비트를 0으로 채울 수 있기 때문에 새로운 코드는 예전 코드를 읽을 수 있다. <code class=\"language-text\">(하위 호환성)</code></li>\n<li>새로운 코드가 기록한 데이터를 예전 코드가 읽는 경우 32비트로 읽게 되므로 값이 잘리게 된다. <code class=\"language-text\">(상위 호환성)</code></li>\n</ul>\n</li>\n<li>프로토콜 버퍼에는 목록이나 배열 데이터타입이 없지만 <code class=\"language-text\">repeated</code> 표시자가 있다.</li>\n<li>이것은 단일 값인 optional 필드를 다중값인 repeated 필드로 변경해도 문제가 없다.</li>\n<li>이전 데이터를 읽는 새로운 코드는 optional 로 읽게 되고, 새로운 데이터를 읽는 예전 코드는 목록의 마지막 엘리먼트만 보게 된다.</li>\n</ul>\n<h3 id=\"스키마의-장점\" style=\"position:relative;\">스키마의 장점<a href=\"#%EC%8A%A4%ED%82%A4%EB%A7%88%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-label=\"스키마의 장점 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>스키마 언어는 XML 스키마나 JSON 스키마보다 훨씬 간단하며 더 자세한 유효성 검사 규칙을 지원한다. <code class=\"language-text\">ex) “이 필드의 문자열 값은 이 정규 표현식에 일치해야 한다”</code></li>\n<li>데이터베이스 벤더는 데이터베이스 네트워크 프로토콜로부터 응답을 인메모리 데이터 구조로 복호화하는 드라이버(ODBC, JDBC API)를 제공한다.</li>\n<li>부호화된 데이터에서 필드 이름을 생략할 수 있기 때문에 크기가 훨씬 작을 수 있다.</li>\n<li>스키마는 유용한 문서화 형식이다. 복호화할 때 스키마가 최신 상태인지를 확신할 수 있다.</li>\n<li>스키마 데이터베이스를 유지하면 스키마 변경이 적용되기 전에 상위 호환성과 하위 호환성을 확인할 수 있다.</li>\n<li>정적 타입 프로그래밍 언어 사용자에게 스키마로부터 코드를 생성하는 기능은 제공할 수 있다.</li>\n</ul>\n<h1>데이터플로우(DataFlow) 모드</h1>\n<ul>\n<li>\n<p>데이터플로우는 매우 추상적인 개념으로서 하나의 프로세스에서 다른 프로세스로 데이터를 전달하는 방법은 아주 많다.</p>\n<ul>\n<li>데이터베이스를 통해</li>\n<li>서비스 호출을 통해</li>\n<li>비동기 메시지 전달을 통해</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"데이터베이스를-통한-데이터플로우\" style=\"position:relative;\">데이터베이스를 통한 데이터플로우<a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%A5%BC-%ED%86%B5%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%94%8C%EB%A1%9C%EC%9A%B0\" aria-label=\"데이터베이스를 통한 데이터플로우 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>데이터베이스에 기록하는 프로세스는 데이터를 부호화하고 데이터베이스에서 읽는 프로세스는 데이터를 복호화한다.</li>\n<li><strong>이전에 기록한 내용을 미래의 자신이 복호화하기 위해 하위 호환성은 분명히 필요하다.</strong></li>\n<li>일반적으로 동시에 다양한 프로세스가 데이터베이스를 접근하는 일은 흔하다.</li>\n<li>일부 프로세스는 새로운 코드를 수행 중이고 일부 다른 프로세스는 예전 코드로 수행 중이라면, 순회식 업그레이드로 현재 새로운 버전을 배포하는 도중이라면 일부 인스턴스는 아직 갱신되지 않았지만 일부 인스턴스는 이미 갱신될 수 있다.</li>\n<li><strong>이것은 데이터베이스 내 값이 새로운 버전의 코드로 기록된 다음 현재 수행 중인 예전 버전의 코드로 그 값을 읽을 가능성이 있기 때문에 상위 호환성도 필요하다.</strong></li>\n<li>새로운 버전의 애플리케이션이 기록한 데이터를 예전 버전의 애플리케이션에서 갱신하는 경우 데이터를 유시할 수 있기 때문에 주의가 필요하다.</li>\n</ul>\n<h3 id=\"다양한-시점에-기록된-다양한-값\" style=\"position:relative;\">다양한 시점에 기록된 다양한 값<a href=\"#%EB%8B%A4%EC%96%91%ED%95%9C-%EC%8B%9C%EC%A0%90%EC%97%90-%EA%B8%B0%EB%A1%9D%EB%90%9C-%EB%8B%A4%EC%96%91%ED%95%9C-%EA%B0%92\" aria-label=\"다양한 시점에 기록된 다양한 값 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>애플리케이션의 새로운 버전을 배포할 때 몇 분내에 예전 버전을 새로운 버전으로 완전히 대체할 수 있지만 데이터베이스는 그렇지 않다.</li>\n<li>5년된 데이터는 그 이후로 명시적으로 다시 기록하지 않는 한 원래의 부호화 상태 그대로 있다. 이런 상황을 <code class=\"language-text\">데이터가 코드보다 더 오래 산다(data outlives code)</code>라 한다.</li>\n<li>데이터를 새로운 스키마로 다시 기록(마이그레이션)하는 작업은 가능하다. 하지만 대용량 데이터셋 대상으로는 값비싼 작업이기 때문에 이런 상황을 피한다.</li>\n<li>대부분의 관계형 데이터베이스는 기존 데이터를 다시 기록하지 않고 널을 기본값으로 갖는 새로운 컬럼을 추가하는 간단한 스키마 변경을 허용한다. <code class=\"language-text\">(MySQL은 전전체 테이블을 다시 기록한다.)</code></li>\n<li>링크드인 문서 데이터베이스인 에스프레소는 아브로 스키마 발전 규칙을 사용한다.</li>\n</ul>\n<h2 id=\"서비스를-통한-데이터플로우-REST와-RPC\" style=\"position:relative;\">서비스를 통한 데이터플로우: REST와 RPC<a href=\"#%EC%84%9C%EB%B9%84%EC%8A%A4%EB%A5%BC-%ED%86%B5%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%94%8C%EB%A1%9C%EC%9A%B0-REST%EC%99%80-RPC\" aria-label=\"서비스를 통한 데이터플로우 REST와 RPC permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>네트워크를 통해 통신해야 하는 프로세스가 있을 때 해당 통신을 배치하는 가장 일반적인 방법은 <strong>클라이언트와 서버의 두 역할로 배치한다.</strong></li>\n<li>웹 브라우저를 위해 서버로 <code class=\"language-text\">GET, POST</code> 요청을 통해 모든 웹 브라우저로 모든 웹사이트를 접속할 수 있다.</li>\n<li>모바일 디바이스나 데스크톱 앱을 통해 서버에 요청할 수 있다. 이 경우 서버 응답은 보통 사람이 볼 수 있게 표시하는 JSON 같은 데이터를 많이 사용한다.</li>\n<li>서버 자체가 다른 서비스의 클라이언트일 수 있다. 하나의 서비스가 다른 서비스의 일부 기능이나 데이터가 필요하다면 해당 서비스에 요청을 보낸다. 이런 개발 방식을 전통적으로 서비스 지향 설계, 최근에는 마이크로서비스 설계라고 한다.</li>\n<li>서비스 지향 및 마이크로서비스 아키텍처의 핵심 설계 목표는 서비스를 배포와 변경에 독립적으로 만들어 애플리케이션 변경과 유지보수를 더 쉽게 할 수 있게 만드는 것 이다.</li>\n<li>각 서비스는 한 팀이 소유해야 하고 해당 팀은 다른 팀과의 조정 없이 자주 서비스의 새로운 버전을 출시할 수 있어야 한다.</li>\n<li><strong>따라서 서버와 클라이언트가 사용하는 데이터 부호화는 서비스 API의 버전 간 호환이 가능해야한다.</strong></li>\n</ul>\n<h3 id=\"웹-서비스\" style=\"position:relative;\">웹 서비스<a href=\"#%EC%9B%B9-%EC%84%9C%EB%B9%84%EC%8A%A4\" aria-label=\"웹 서비스 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>웹 서비스에는 대중적인 <code class=\"language-text\">REST</code>와 <code class=\"language-text\">SOAP</code>가 있다.</li>\n<li><code class=\"language-text\">REST</code> 는 프로토콜이 아니라 HTTP의 원칙을 토대로 한 설계 철학이다.</li>\n<li><code class=\"language-text\">REST</code> 는 간단한 데이터 타입을 강조하며 URL을 사용해 리소스를 식별하고 캐시 제어, 인증, 콘텐츠 유형 협상에 HTTP 기능을 사용한다.</li>\n<li><code class=\"language-text\">SOAP</code> 는 네트워크 API 요청을 위한 XML 기반 프로토콜이다.</li>\n<li>HTTP와 독립적이며 대부분의 HTTP 기능을 사용하지 않는다.</li>\n<li><code class=\"language-text\">SOAP</code> 웹 서비스의 API는 웹 서비스 기술 언어(WSDL)의 XML 기반 언어를 사용해 기술한다.</li>\n<li>WSDL은 클라이언트가 로컬 클래스와 메서드 호출을 사용해 원격 서비스에 접근하는 코드 생성이 가능하다.</li>\n<li>WSDL은 사람이 읽을 수 있게 설계하지 않았고 SOAP 메시지를 수동으로 구성하기에는 너무 복잡하기 때문에 SOAP 사용자는 도구 지원과 코드 생성과 IDE에 크게 의존한다.</li>\n</ul>\n<h3 id=\"원격-프로시저-호출RPC-문제\" style=\"position:relative;\">원격 프로시저 호출(RPC) 문제<a href=\"#%EC%9B%90%EA%B2%A9-%ED%94%84%EB%A1%9C%EC%8B%9C%EC%A0%80-%ED%98%B8%EC%B6%9CRPC-%EB%AC%B8%EC%A0%9C\" aria-label=\"원격 프로시저 호출RPC 문제 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>\n<p>웹 서비스는 네트워크 상에서 API 요청을 하기 위한 여러 기술 중 하나이다.</p>\n<ul>\n<li>EJB, RMI 는 자바로만 제한된다.</li>\n<li>분산 컴포넌트 객체모델(DCOM)은 마이크로소프트 플랫폼으로 제한된다.</li>\n<li>공통 객체 요청 브로커 설계(CORBA)는 지나치게 복잡하고 하위,상위 호환성을 제공하지 않는다.</li>\n</ul>\n</li>\n<li>이러한 웹 서비스는 원격 프로시저 호출(RPC)의 아이디어를 기반으로 한다.</li>\n<li>RPC 모델은 원격 네트워크 서비스 요청을 같은 프로세스 안에서 특정 프로그래밍 언어의 함수나 메서드를 호출하는 것과 동일하게 사용 가능하게 해준다.</li>\n<li>\n<p>RPC 가 처음에는 편리한 것 같지만 근본적으로 결함이 있다.</p>\n<ul>\n<li>로컬 함수는 예측 가능하다. 그래서 제어 가능한 매개변수에 따라 성공하거나 실패한다.</li>\n<li>네트워크 요청은 어렵다. 네트워크 문제로 요청과 응답이 유실되거나 요청에 응답하지 않을 수 있다.</li>\n<li>예를 들어 실패한 요청을 다시 보내는 것과 같은 대첵을 세워야 한다.</li>\n</ul>\n</li>\n<li><em>네트워크 요청은 타임아웃으로 결과 없이 반환될 수 있다.</em></li>\n<li><em>실패한 네트워크 요청을 다시 시도할 때 요청이 실제로는 처리되고 응답만 유실될 수 있다. 이 경우 프로토콜에 중복 제거기법을 적용하지 않으면 재시도는 작업이 여러번 수행되는 원인이 된다.</em></li>\n<li><em>네트워크 요청은 함수 호출보다 훨씬 느리고 지연 시간은 매우 다양하다.</em></li>\n<li><em>네트워크 요청은 모든 매개변수를 네트워크로 전송할 수 있게끔 바이트열로 부호화해야한다.</em></li>\n<li><em>클라이언트와 서비스는 다른 프로그래밍 언어로 구현할 수 있다. 모든 언어가 같은 타입을 가지는 것은 아니기에 깔끔하지 않는 모습이 될 수 있다.</em></li>\n</ul>\n<h3 id=\"RPC의-현재-방향\" style=\"position:relative;\">RPC의 현재 방향<a href=\"#RPC%EC%9D%98-%ED%98%84%EC%9E%AC-%EB%B0%A9%ED%96%A5\" aria-label=\"RPC의 현재 방향 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>gRPC는 프로토콜 버퍼를 이용한 RPC 구현이다.</li>\n<li>차세대 RPC 프레임워크는 원격 요청이 로컬 함수 호출과 다르다는 사실을 더욱 분명히 한다.</li>\n<li>Rest.li는 실패할지도 모를 비동기 작업을 캡슐화하기 위해 <code class=\"language-text\">퓨처(future)</code>를 사용한다.</li>\n<li>REST 상에서 JSON과 같은 부류의 프로토콜보다 이진 부호화 형식을 사용하는 사용자 정의 RPC 프로토콜이 우수한 성능을 제공할 수 도 있다.</li>\n<li>\n<p>RESTful API는 다른 중요한 이점이 있다.</p>\n<ul>\n<li>테스트와 디버깅에 적합(웹 브라우저나 curl을 사용해 간단히 요청을 보낼 수 있다)</li>\n<li>모든 주요 프로그래밍 언어와 플랫폼이 지원하고 사용 가능한 다양한 도구 생태계(서버, 캐시 로드 밸런서, 프록시, 방화벽, 모니터링, 디버깅 도구, 테스팅 도구)등이 있다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"메시지-전달-데이터-플로\" style=\"position:relative;\">메시지 전달 데이터 플로<a href=\"#%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%A0%84%EB%8B%AC-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%94%8C%EB%A1%9C\" aria-label=\"메시지 전달 데이터 플로 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>RPC와 데이터베이스 간 비동기 메시지 전달 시스템을 살펴본다.</li>\n<li>이 시스템은 클라이언트 요청을 낮은 지연 시간으로 다른 프로세스에 전달한다는 점에서는 RPC와 비슷하다.</li>\n<li>메시지를 직접 네트워크 연결로 전송하지 않고 임시로 메시지를 저장하는 <code class=\"language-text\">메시지 브로커(message broker)(또는 메시지 큐)나 메시지 지향 미들웨어</code> 라는 중간 단계를 거쳐 전송한다는 점은 데이터베이스와 유사하다.</li>\n<li>\n<p>메시지 브로커를 사용하는 방식은 직접 RPC를 사용하는 방식과 비교했을 때 여러 장점이 있다.</p>\n<ul>\n<li>수신자가 사용 불가능하거나 과부하 상태라면 메시지 브로커가 버퍼처럼 동작할 수 있기 때문에 시스템 안정성이 향상된다.</li>\n<li>죽었던 프로세스에 메시지를 다시 전달할 수 있기 때문에 메시지 유실을 방지할 수 있다.</li>\n<li>송신자가 수신자의 IP 주소나 포트 번호를 알 필요가 없다.</li>\n<li>하나의 메시지를 여러 수신자로 전송할 수 있다.</li>\n<li>논리적으로 송신자는 수신자와 분리된다.</li>\n</ul>\n</li>\n<li>메시지 전달 통신은 일반적으로 단방향이라는 점이 RPC와 다르다.</li>\n<li>대게 송신 프로세스는 메시지에 대한 응답을 기대하지 않는다.</li>\n</ul>\n<h3 id=\"메시지-브로커\" style=\"position:relative;\">메시지 브로커<a href=\"#%EB%A9%94%EC%8B%9C%EC%A7%80-%EB%B8%8C%EB%A1%9C%EC%BB%A4\" aria-label=\"메시지 브로커 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>프로세스 하나가 메시지를 이름이 저장된 큐나 토픽으로 전송하고 브로커는 해당 큐나 토픽 하나 이상의 소비자 또는 구독자에게 메시지를 전달한다.</li>\n<li>동일한 토픽에 여러 생산자와 소비자가 있을 수 있다.</li>\n<li>토픽은 단방향 데이터 플로우만 제공한다.</li>\n<li>하지만 소비자 스스로 메시지를 다른 토픽으로 게시하거나 원본 메시지의 송신자가 소비하는 응답 큐로 게시할 수 있다.</li>\n<li>메시지는 일부 메타데이터를 가진 바이트열로 모든 부호화 형식을 사용할 수 있다.</li>\n<li><strong>부호화가 상하위 호환성을 모두 가진다면 메시지 브로커에서 게시자와 소비자를 독립적으로 변경해 임의 순서로 배포할 수 있는 유연성을 얻게 된다.</strong></li>\n</ul>\n<h3 id=\"분산-액터-프레임워크\" style=\"position:relative;\">분산 액터 프레임워크<a href=\"#%EB%B6%84%EC%82%B0-%EC%95%A1%ED%84%B0-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC\" aria-label=\"분산 액터 프레임워크 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li><strong>액터 모델(actor model)</strong>은 단일 프로세스 안에서 동시성을 위한 프로그래밍 모델이다.</li>\n<li>스레드를 직접 처리하는 대신 로직이 액터에 캡슐화 된다.</li>\n<li>액터는 하나의 클라이언트나 엔티티를 나타낸다.</li>\n<li>액터는 로컬 상태를 가질 수 있고 비동기 메시지의 송수신으로 다른 액터와 통신한다.</li>\n<li>각 액터 프로세스는 한 번에 하나의 메시지만 처리하기 때문에 스레드에 대해 걱정할 필요가 없고 각 액터는 프레임워크와 독립적으로 실행할 수 있다.</li>\n<li>이 프로그래밍 모델은 여러 노드 간의 애플리케이션 확장에 사용된다.</li>\n<li>송신자와 수신자가 같은 노드에 있는지 다른 노드에 있는지 관계없이 동일한 메시지 전달 구조를 사용한다.</li>\n<li>다른 노드에 있는 경우 메시지는 명백하게 바이트열로 부호화되고 네트워크를 통해 전송되며 다른 쪽에서 복호화한다.</li>\n<li>액터 모델은 단일 프로세스 안에서도 메시지가 유실될 수 있다고 가정하기 때문에 위치 투명성은 RPC보다 액터 모델에서 더 잘 동작한다.</li>\n</ul>\n<h1>정리</h1>\n<ul>\n<li>데이터 구조를 네트워크나 디스크 상의 바이트열로 변환하는 다양한 방법이 있다.</li>\n<li>이런 부호화의 세부 사항은 효율성뿐만 아니라 애플리케이션의 아키텍처와 배포의 선택 사항에도 영향을 미친다.</li>\n<li>많은 서비스가 새로운 버전의 서비스를 동시에 모든 노드에 배포하는 방식보다 한 번에 일부 노드에만 서서히 배포하는 순회식 업그레이드가 필요하다.</li>\n<li>순회식 업그레이드는 정지 시간 없이 새로운 버전의 서비스를 출시 가능하게 하고 배포를 덜 위험하게 만든다.</li>\n<li>여러 가지 다른 이유로 다양한 노드에서 다른 버전의 여러 애플리케이션 코드가 실행될 수 있다.</li>\n<li>따라서 시스템을 흐르는 모든 데이터는 하위 호환성, 상위 호환성을 제공하는 방식으로 부호화해야 한다.</li>\n</ul>","fields":{"slug":"/ch4/","thumbnail":null},"frontmatter":{"date":"January 18, 2022","update":"Jan 18, 2022","title":"4장 - 부호화와 발전","description":null,"tags":["데이터 중심 애플리케이션 설계"],"thumbnail":null}},{"excerpt":"데이터베이스를 강력하게 만드는 데이터 구조 일반적으로 파일 추가 작업은 매우 효율적이기 때문에 로그(log)를 기록할 때 파일을 사용한다. 하지만 파일에서 특정 로그키를 찾을 때마다  만큼 걸리기 때문에 성능이 매우 좋지 않다. 데이터베이스에서 특정 키의 값을 효율적으로 찾기 위해서는 가 필요하다. 색인의 일반적인 개념은 어떤 부가적인 메타데이터를 유지하…","html":"<h1>데이터베이스를 강력하게 만드는 데이터 구조</h1>\n<ul>\n<li>일반적으로 파일 추가 작업은 매우 효율적이기 때문에 로그(log)를 기록할 때 파일을 사용한다.</li>\n<li>하지만 파일에서 특정 로그키를 찾을 때마다 <code class=\"language-text\">O(n)</code> 만큼 걸리기 때문에 성능이 매우 좋지 않다.</li>\n<li>데이터베이스에서 특정 키의 값을 효율적으로 찾기 위해서는 <code class=\"language-text\">색인구조</code>가 필요하다.</li>\n<li>색인의 일반적인 개념은 어떤 부가적인 메타데이터를 유지하는 것이다.</li>\n<li>색인을 잘 선택했다면 <strong>읽기 질의 속도가 향상되지만</strong> <strong>모든 색인은 쓰기 속도를 떨어뜨린다</strong>.</li>\n</ul>\n<!-- more -->\n<h3 id=\"해시-색인\" style=\"position:relative;\">해시 색인<a href=\"#%ED%95%B4%EC%8B%9C-%EC%83%89%EC%9D%B8\" aria-label=\"해시 색인 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>키-값 데이터를 색인하기 위해 보통 해시 맵으로 구현한다.</li>\n<li>\n<p><code class=\"language-text\">모든 키값과 매핑되는 바이트 오프셋을 유지하는 방법</code></p>\n<ul>\n<li>매우 단순하지만 해시 맵을 전부 메모리에 유지하기 때문에 고성능으로 읽기, 쓰기가 보장된다.</li>\n<li>각 키의 값이 자주 갱싱되는 상황에 매우 적합하다.</li>\n<li>예를 들어 키는 동영상 URL 이고, 값은 비디오가 재생된 횟수인 경우다.</li>\n<li>이런 유형의 작업부하에서는 쓰기가 아주 많지만 고유 키는 많지 않다.</li>\n<li>하지만 용량에 커지게 된다면 결국 디스크 공간이 부족해진다.</li>\n</ul>\n</li>\n<li>\n<p>특정 크기의 세그먼트로 로그를 나누는 방식</p>\n<ul>\n<li>특정 크기에 도달하면 세그먼트 파일을 닫고 새로운 세그먼트 파일에 이후 쓰기를 수행한다.</li>\n<li>컴팩션(compation)은 로그에서 중복된 키를 버리고 각 키의 최신 갱신 값만 유지하는 것을 의미한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"추가-전용-쓰기-설계는-낭비인가\" style=\"position:relative;\">추가 전용 쓰기 설계는 낭비인가?<a href=\"#%EC%B6%94%EA%B0%80-%EC%A0%84%EC%9A%A9-%EC%93%B0%EA%B8%B0-%EC%84%A4%EA%B3%84%EB%8A%94-%EB%82%AD%EB%B9%84%EC%9D%B8%EA%B0%80\" aria-label=\"추가 전용 쓰기 설계는 낭비인가 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>추가와 세그먼트 병합은 순차적인 쓰기 작업이기 때문에 무작위 쓰기보다 훨씬 빠르다.</li>\n<li>세그먼트 파일이 추가 전용이나 불변이면 동시성과 고장 복구는 훨씬 간단하다.</li>\n<li>오래된 세그먼트 병합은 시간이 지남에 따라 조각화되는 데이터 파일 문제를 피할 수 있다.</li>\n</ul>\n<h3 id=\"해시-테이블-색인의-제한사항\" style=\"position:relative;\">해시 테이블 색인의 제한사항<a href=\"#%ED%95%B4%EC%8B%9C-%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%83%89%EC%9D%B8%EC%9D%98-%EC%A0%9C%ED%95%9C%EC%82%AC%ED%95%AD\" aria-label=\"해시 테이블 색인의 제한사항 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>해시 테이블은 메모리에 저장해야 하므로 키가 너무 많으면 문제가 된다.</li>\n<li>해시 테이블은 범위 질의에 효율적이지 않다.</li>\n</ul>\n<h3 id=\"SS테이블과-LSM-트리\" style=\"position:relative;\">SS테이블과 LSM 트리<a href=\"#SS%ED%85%8C%EC%9D%B4%EB%B8%94%EA%B3%BC-LSM-%ED%8A%B8%EB%A6%AC\" aria-label=\"SS테이블과 LSM 트리 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>키-값 쌍을 가지는 세그먼트 구조에서 키-값 쌍을 키로 정렬하는 것을  정렬된 문자열 테이블(SS) 테이블이라고 한다.</li>\n<li>\n<p>SS 테이블은 해시 색인을 가진 로그 세그먼트보다 몇 가지 큰 장점이 있다.</p>\n<ul>\n<li>각 세그먼트들이 정렬되어 있기 때문에 병합정렬 알고리즘이 사용가능하다.</li>\n<li>세그먼트 병합이 파일이 사용 가능한 메모리보다 크더라도 간단하고 효율적이다.</li>\n<li>파일에서 특정 키를 찾기 위해 메모리에 모든 키의 색인을 유지할 필요가 없다.</li>\n<li>읽기 요청은 요청 범위 내에서 여러 키-값을 스캔해야 하기 때문에 해당 레코드들을 블록으로 그룹화하고 디슼에 쓰기 전에 압축한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"SS테이블-생성과-유지\" style=\"position:relative;\">SS테이블 생성과 유지<a href=\"#SS%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%83%9D%EC%84%B1%EA%B3%BC-%EC%9C%A0%EC%A7%80\" aria-label=\"SS테이블 생성과 유지 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>B 트리 구조를 사용해서 디스크상에 정렬된 구조를 유지할 수 있다.</li>\n<li>\n<p>하지만 레드 블랙 트리나 AVL 트리로 메모리에 유지하는 편이 훨씬 쉽다.</p>\n<ul>\n<li>쓰기가 들어오면 인메모리 균형 트리 데이터구조에 추가한다. 이 인메모리 트리는 <strong>멤테이블(memtable)</strong> 이라고 한다.</li>\n<li>멤테이블의 메가바이트 정도의 임곗값보다 커지면 SS테이블 파일로 디스크에 기록한다. <strong>트리가 이미 키로 정렬되어 있기 때문에 효율적으로 수핼할 수 있다.</strong></li>\n<li>새로운 SS테이블 파일은 데이터베이스의 가장 최신 세그먼트가 된다. SS테이블을 디스크에 기록하는 동안 쓰기는 새로운 멤테이블에 계속 된다.</li>\n<li>읽기 요청을 제공하려면 먼저 멤테이블에서 키를 찾고, 디스크 상의 가장 최신 세그먼트순으로 찾는다.</li>\n<li>세그먼트 파일을 합치고 덮어 쓰여지거나 삭제된 값을 버리는 병합과 컴팩션 과정을 백그라운드로 수행한다.</li>\n</ul>\n</li>\n<li>데이터베이스가 고장나면 디스크에 기록되지 않고 멤테이블에 있는 가장 최신 쓰기가 손실된다.</li>\n<li>이 문제를 피하기 위해서 매번 쓰기를 즉시 추가할 수 있게 분리된 로그를 디스크 상에 유지해야된다.</li>\n</ul>\n<h3 id=\"SS테이블에서-LSM-트리-만들기\" style=\"position:relative;\">SS테이블에서 LSM 트리 만들기<a href=\"#SS%ED%85%8C%EC%9D%B4%EB%B8%94%EC%97%90%EC%84%9C-LSM-%ED%8A%B8%EB%A6%AC-%EB%A7%8C%EB%93%A4%EA%B8%B0\" aria-label=\"SS테이블에서 LSM 트리 만들기 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>이런 알고리즘은 키-값 저장소 엔진 라이브러리에서 사용된다.</li>\n<li>구글의 빅테이블, 카산드라, HBase 등에서도 유사한 저장소 엔진을 사용한다.</li>\n<li>원래 이 색인 구조는 <code class=\"language-text\">로그 구조화 병합 트리(Log-Structured Merge-Tree)(또는 LSM 트리)</code>라고 부른다.</li>\n</ul>\n<h3 id=\"성능-최적화\" style=\"position:relative;\">성능 최적화<a href=\"#%EC%84%B1%EB%8A%A5-%EC%B5%9C%EC%A0%81%ED%99%94\" aria-label=\"성능 최적화 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>LSM 트리 알고리즘은 데이터베이스에 존재하지 않는 키를 찾는 경우 느릴 수 있다.</li>\n<li>멤테이블에 확인한 다음 키가 존재하지 않는다는 사실을 확인하기 전에는 가장 오래된 세그먼트까지 거슬러 올라가야 한다.</li>\n<li>이런 종류의 접근을 최적화하기 위해 저장소 엔진은 보통 <strong>블룸 필터(Bloom filter)</strong>를 추가적으로 사용한다.</li>\n<li>블룸 필터는 키가 데이터베이스에 존재하지 않음을 알려주므로 존재하지 않는 키를 불필요한 디스크 읽기를 많이 절약할 수 있다.</li>\n<li>SS테이이블을 압축하고 병합하는 순서와 시기를 결정하는 전략으로 <strong>크기 계층(size-triered)과 레벨 컴팩션(leveled compaction)</strong>가 있다.</li>\n<li>사이즈 계층 컴팩션은 상대적으로 좀 더 새롭고 작은 SS테이블을 상대적으로 오래됐고 큰 SS테이블에 연이어 병합한다.</li>\n<li>레벨 컴팩션은 키 범위를 더 작은 SS테이블을 나누고 오래된 데이터는 개별 레벨로 이동하기 때문에 컴팩션을 점진적으로 진행해 디스크 공간을 덜 사용한다.</li>\n</ul>\n<h3 id=\"B-트리\" style=\"position:relative;\">B 트리<a href=\"#B-%ED%8A%B8%EB%A6%AC\" aria-label=\"B 트리 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>가장 널리 사용되는 색인 구조는 <strong>B트리(B-tree)</strong> 이다.</li>\n<li>앞에서 살펴본 LSM 트리는 수 메가바이트 이상의 가변 크기를 가진 세그먼트로 나누고 순차적으로 세그먼트를 기록한다.</li>\n<li>반면 B트리는 4KB 크기의 고정 크기 블록이나 페이지로 나누고 한 번에 하나의 페이지에 읽기 또는 쓰기를 한다.</li>\n<li>디스크가 고정 크기 블록으로 배열되기 때문에 이런 설게는 근본적으로 하드웨어와 조금 더 밀접하 관련이 있다.</li>\n<li>하나의 페이지는 B 트리의 루트(root)로 지정되고, 페이지는 여러 키와 하위 페이지의 참조를 포함한다.</li>\n<li>각 하위 페이지는 키가 이어지는 범위를 담당하고 참조 사이의 키는 해당 범위 경계가 어디인지 나타낸다.</li>\n<li>탐색을 위해서 루트에서 시작하여 페이지 경계 사이로 페이지 참조를 따라가고 최종적으로 <strong>리프 페이지(leaf page)</strong>를 포함하는 페이지에 도달한다.</li>\n<li>B 트리에서 한 페이지에서 하위 페이지를 참조하는 수를 <code class=\"language-text\">분기 계수(bracning factor)</code> 라고 부르고, 분기 계수는 페이지 참조와 범위 경계를 저장할 공간의 양에 의존적인데 보통 수백게에 달한다.</li>\n<li>B 트리에 존재하는 <strong>키의 값을 갱신하려면</strong> 키를 포함하고 있는 리프 페이지를 검색하고 페이지의 값을 바꾼 다음 페이지를 디스크에 다시 기록한다.</li>\n<li>새로운 키를 추가하려면 새로운 키를 포함하는 범위의 페이지를 찾아 해당 페이지에 키와 값을 추가한다.</li>\n<li>새로운 키를 수용한 페이지에 충분한 여유 공간이 없다면 페이지 하나를 반쯤 채워진 페이지 둘로 나누고 상위 페이지가 새로운 키 범위의 하위 부분들을 알 수 있게 생긴한다.</li>\n<li>이 알고리즘은 트리가 계속 균형을 유지하는 것을 보장한다.</li>\n<li>분기 계수 500의 4KB 페이지의 4단계 트리는 256TB까지 저장할 수 있다.</li>\n</ul>\n<h3 id=\"신뢰할-수-있는-B-트리-만들기\" style=\"position:relative;\">신뢰할 수 있는 B 트리 만들기<a href=\"#%EC%8B%A0%EB%A2%B0%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-B-%ED%8A%B8%EB%A6%AC-%EB%A7%8C%EB%93%A4%EA%B8%B0\" aria-label=\"신뢰할 수 있는 B 트리 만들기 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>B 트리의 기본적인 쓰기 동작은 새로운 데이터를 디스크 사으이 기존 페이지에 덮어쓴다.</li>\n<li>즉, 페이지를 덮어쓰더라도 페이지를 가르키는 모든 참조는 변하지 않는다.</li>\n<li>LSM 트리와 같은 로그 구조화 색인과는 대조적인 점이다.</li>\n<li>B 트리의 삽입 과정 중 페이지가 너무 커져 페이지를 나눠야 할 때, 데이터베이스가 고장 난다면 색인이 훼손될 수 있기 때문에 이것은 위험한 동작이다.</li>\n<li>데이터베이스가 고장 상황에서 스스로 복구할 수 있게 만들려면 디스크 상에 <code class=\"language-text\">쓰기 전 로그(write,ahead log, WAL)(재실행 로그(redo log)</code>라고 하는 데이터 구조를 추가할 수 있다.</li>\n<li>쓰기 전 로그는 트리 페이지에 변경된 내용을 적용하기 전에 모든 B트리의 변경사항을 기록하는 추가 전용 로그이다.</li>\n<li>같은 자리에 페이지를 갱신하는 작업할 때, 다중 스레드가 동시에 B 트리에 접근한다면 주의 깊게 동시성 제어를 해야 한다.</li>\n<li>동시성 제어는 보통 래치(latch)로 트리의 데이터 구조를 보호한다.</li>\n</ul>\n<h3 id=\"B-트리-최적화\" style=\"position:relative;\">B 트리 최적화<a href=\"#B-%ED%8A%B8%EB%A6%AC-%EC%B5%9C%EC%A0%81%ED%99%94\" aria-label=\"B 트리 최적화 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>쓰기전 로그(WAL) 유지 대신 일부 데이터 베이스는 <code class=\"language-text\">쓰기 시 복사 방식(copy-on-write schem)</code>을 사용한다. 변경된 페이지는 다른 위치에 기록하고 트리에 상위 페이지의 새로운 버전을 만들어 새로운 위치를 가르키게 한다.</li>\n<li>페이지 전체 키가 저장하는게 아니라 키를 축약해 쓰면 공간을 절약할 수 있다. 키가 키 범위 사이의 경계 역할을 하는 데 충분한 정보만 제공하면 된다. 페이지 하나에 키를 더 많이 채우면 트리는 더 높은 분기 계수를 얻는다. 트리 깊이 수준을 낮출 수 있다.</li>\n<li>\n<p>B 트리 구현에서 리프 페이지를 디스크 상에 연속된 순서로 나타나게끔 트리르 배치한다.</p>\n<ul>\n<li>일반적으로 페이지는 디스크 상에 위치할 수 있다. 질의가 정렬된 순서로 키 범위의 상단 부분을 스캔해야 된다면 모든 페이지에 대해 디스크 찾기가 필요하기 때문에 비효율적이다.</li>\n<li>하지만 트리가 커지면 순서를 유지하기 어렵다. 반대로 LSM 트리는 병합하는 과정에서 저장소의 큰 세그먼트를 한 번에 다시 쓰기 때문에 디스크에서 연속된 키를 서로 가깝게 유지하기 쉽다.</li>\n</ul>\n</li>\n<li>트리에 포인터를 추가한다. 각 리프 페이지의 양쪽 형제 페이지에 대한 참조를 가지면 상위 페이지로 다시 이동하지 않아도 순서대로 키를 스캔할 수 있다.</li>\n</ul>\n<h3 id=\"LSM-트리의-장점\" style=\"position:relative;\">LSM 트리의 장점<a href=\"#LSM-%ED%8A%B8%EB%A6%AC%EC%9D%98-%EC%9E%A5%EC%A0%90\" aria-label=\"LSM 트리의 장점 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>\n<p>B 트리보다 쓰기 처리량을 높게 유지할 수 있다.</p>\n<ul>\n<li>B 트리 색인은 모든 데이터 조각을 최소한 두 번 기록해야 한다.</li>\n<li>해당 페이지내 몇 바이트만 바뀌어도 한 번에 전체 페이지를 기록해야 하는 오버헤드도 있다.</li>\n<li>로그 구조화 색인 또한 SS 테이블의 반복된 컴팩션과 병합으로 여러 번 데이터를 쓴다.</li>\n<li>데이터베이스에 쓰기 한 번이 데이터베이스 수명 동안 디스크에 여러 번의 쓰기를 야기하는 이렇ㄴ 효과를 쓰기 증폭이라 한다.</li>\n<li>LSM 트리가 상대적으로 쓰기 증폭이 더 낮다. 트리에서 여러 페이지를 덮어쓰는 것이 아니라 순차적으로 컴팩션된 SS테이블 파일을 쓰기 떄문이다.</li>\n</ul>\n</li>\n<li>\n<p>LSM 트리는 압축률이 더 좋다.</p>\n<ul>\n<li>B 트리 저장소 엔진은 파편화로 인해 사용하지 않는 디스크 공간 일부가 남는다.</li>\n<li>LSM 트리는 페이지 지향적이지 않고 주기적으로 파편화를 없애기 위해 SS테이블을 다시 기록하기 때문에 저장소 오버헤드가 더 낮다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"LSM-트리의-단점\" style=\"position:relative;\">LSM 트리의 단점<a href=\"#LSM-%ED%8A%B8%EB%A6%AC%EC%9D%98-%EB%8B%A8%EC%A0%90\" aria-label=\"LSM 트리의 단점 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>\n<p>컴팩션 과정이 때로는 진행 중인 읽기와 쓰기의 성능에 영향을 준다.</p>\n<ul>\n<li>디스크에서 비싼 컴팩션 연산이 끝날 때까지 요청이 대기해야 하는 상황이 발생하기 쉽다.</li>\n<li>B 트리의 성능은 로그 구조화 저장소 엔진보다 예측하기 쉽다.</li>\n</ul>\n</li>\n<li>\n<p>컴팩션 문제는 높은 쓰기 처리량에서 발생한다.</p>\n<ul>\n<li>초기 쓰기(로깅)과 멤테이블을 디스크로 플러싱과 백그라운드에서 수행되는 컴팩션 스레드가 이 대역폭을 공유해야 한다.</li>\n<li>데이터베이스가 점점 커질수록 컴팩션을 위해 더 많은 디스크 대역폭이 필요하다.</li>\n</ul>\n</li>\n<li>쓰기 처리량이 높음에도 컴팩션 설정을 주의 깊게 하지 않으면 컴팩션 유입 쓰기 속도를 따라갈 수 가없다.</li>\n<li>\n<p>로그 구조화 저장소 엔진은 다른 세그먼트에 같은 키의 다중 복사본이 존재할 수 있다.</p>\n<ul>\n<li>B 트리의 장점은 각 키가 색인의 한 곳에만 정확하게 존재한다는 점이다.</li>\n<li>강력한 트랜잭션 시맨틱을 제공하는 데이터베이스에는 B 트리가 훨씬 매력적이다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"기타-색인-구조\" style=\"position:relative;\">기타 색인 구조<a href=\"#%EA%B8%B0%ED%83%80-%EC%83%89%EC%9D%B8-%EA%B5%AC%EC%A1%B0\" aria-label=\"기타 색인 구조 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>키-값 색인의 대표적인 예는 관계형 모델의 <strong>기본키(primary key) 색인</strong>이다.</li>\n<li><code class=\"language-text\">보조 색인(secondary index)</code>을 사용하는 방식도 매우 일반적이다. 보조 색인은 키-값 색인에서 쉽게 생성할 수 있다.</li>\n<li>기본키 색인과 주요 차이점은 키가 고유하지 않다는 점 이다.</li>\n</ul>\n<h3 id=\"색인-안에-값-저장하기\" style=\"position:relative;\">색인 안에 값 저장하기<a href=\"#%EC%83%89%EC%9D%B8-%EC%95%88%EC%97%90-%EA%B0%92-%EC%A0%80%EC%9E%A5%ED%95%98%EA%B8%B0\" aria-label=\"색인 안에 값 저장하기 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>색인에서 키는 질의가 검색하는 대상이지만 값은 다음의 두 가지 중 하나에 해당한다.</li>\n<li>값은 질의의 실제 로우(문서, 정점)이거나 다른 곳에 저장된 로우를 가르키는 참조다.</li>\n<li>\n<p>후자의 경우 로우가 저장된 곳을 <code class=\"language-text\">힙 파일(heap file)</code>이라고 한다.</p>\n<ul>\n<li>여러 보조 색인이 존재할 때 힙 파일 접근은 중복된 데이터를 피할 수 있다.</li>\n<li>힙 파일 접근 방식은 키를 변경하지 않고 값을 갱신할 때 꽤 효율적이다.</li>\n</ul>\n</li>\n<li>색인 안에 색인된 로우를 저장하는 방식을 클러스터드 <code class=\"language-text\">색인(clustered index)</code>이라고 한다.</li>\n<li><code class=\"language-text\">클러스터드 색인(색인 안에 모든 로우 데이터를 저장)</code>과 비클러스터드 <code class=\"language-text\">색인(색인 안에 데이터의 참조만 저장)</code> 사이의 절충안을 <strong>커버링 색인(convering index)</strong>이라 한다.</li>\n<li>이 색인은 색인 안에 테이블의 컬럼 일부를 저장한다. 이렇게 하면 일부 질의에 대해서 색인만 사용해 응답이 가능하다. <code class=\"language-text\">(이런 경우를 색인이 질의를 커버했다고 말한다)</code></li>\n</ul>\n<h3 id=\"다중-컬럼-색인\" style=\"position:relative;\">다중 컬럼 색인<a href=\"#%EB%8B%A4%EC%A4%91-%EC%BB%AC%EB%9F%BC-%EC%83%89%EC%9D%B8\" aria-label=\"다중 컬럼 색인 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>다중 컬럼 색인의 가장 일반적인 유형은 <code class=\"language-text\">결합 색인(concatenated index)</code>이라고 한다.</li>\n<li>결합 색인은 하나의 컬럼에 다른 컬럼을 추가하는 방식으로 하나의 키에 여러 필드를 단순히 결합한다.</li>\n<li>이 방법은 <strong>(성, 이름)</strong>을 키로 전화번호를 값으로 하는 색인을 제공하는 방식과 유사하다.</li>\n<li>순서가 정렬돼 있기 때문에 특정 성을 가진 모든 사람을 찾거나 특정 성 이름을 조합을 가진 모든 사람을 찾을 때도 이 색인을 사용할 수 있다.</li>\n<li>하지만 특정 이름을 가진 모든 사람을 찾을 때는 쓸모가 없다.</li>\n</ul>\n<h3 id=\"모든-것을-메모리에-보관\" style=\"position:relative;\">모든 것을 메모리에 보관<a href=\"#%EB%AA%A8%EB%93%A0-%EA%B2%83%EC%9D%84-%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%97%90-%EB%B3%B4%EA%B4%80\" aria-label=\"모든 것을 메모리에 보관 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>지금까지 설명한 데이터 구조는 모두 디스크 한계에 대한 해결책이었다.</li>\n<li>인메모리 데이터베이스도 지속성을 목표로 특수 하드웨어를 사용하거나 디스크에 변경 사항의 로그를 기록하거나 디스크에 주기적인 스냅숏을 기록하거나 다른 장비에 인메로리 상태를 복제하는 방법이 있다.</li>\n<li>레디스는 비동기로 디스크에 기록하기 때문에 약한 지속성을 제공한다.</li>\n</ul>\n<h3 id=\"트랜잭션-처리나-분석\" style=\"position:relative;\">트랜잭션 처리나 분석<a href=\"#%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EC%B2%98%EB%A6%AC%EB%82%98-%EB%B6%84%EC%84%9D\" aria-label=\"트랜잭션 처리나 분석 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<aside>\n💡 트랜잭션이 반드시 ACID 속성을 가질 필요는 없다. 트랜잭션 처리는 주기적으로 수행되는 일괄 처리 작업과 달리 클라이언트가 지연 시간이 낮은 읽기와 쓰기를 가능하게 한다는 의미다.\n</aside>\n<ul>\n<li>비록 데이터베이스가 많은 여러 종류의 데이터를 사용하기 시작했지만 기본적인 접근 패턴은 비지니스 트랜잭션 처리와 유사하다.</li>\n<li>보통 애플리케이션은 색인을 사용해 일부 키에 대한 적은 수의 레코드를 찾는다. 레코드는 사용자 입력을 기반으로 삽입되거나 갱신된다.</li>\n<li>이런 애플리케이션은 대화식이기 때문에 이 접근 패턴을 <code class=\"language-text\">온라인 트랜잭션 처리(OLTP)</code> 라고 한다.</li>\n<li>다른 패턴으로 많은 수의 레코드를 스캔해 레코드 당 일부 컬럼만 읽어 집계 통계를 계산해야 한다.</li>\n<li>이런 질의는 보통 비지니스 분석가가 작성하며 회사 경영진이 더 나은 의사결정을 하게끔 돕는 보고서를 제공한다. 이런 데이터베이스 사용 패턴을 <code class=\"language-text\">온라인 분석 처리(OLAP)</code>라고 한다.</li>\n<li>처음에는 트랜잭션 처리와 분석 질의를 위해 동일한 데이터베이스를 사용했다.</li>\n<li>이와 관련해서 SQL은 OLTP, OLAP 유형 질의 모두 잘 동작했다.</li>\n<li>몇몇 회사들은 OLAP를위한 개별 데이터베이스에서 분석을 수행하기도 했다. 이 개별 데이터베이스를 <code class=\"language-text\">데이터 웨어하우스(data warehouse)</code>라고 한다.</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>특성</th>\n<th>트랜잭션 처리 시스템(OLTP)</th>\n<th>분석 시스템(OLAP)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>주요 읽기 패턴</td>\n<td>질의당 적은 수의 레코드, 키 기준으로 가져옴</td>\n<td>많은 레코드에 대한 집계</td>\n</tr>\n<tr>\n<td>주요 쓰기 패턴</td>\n<td>임의 접근, 사용자 입력을 낮은 지연 시간으로 기록</td>\n<td>대규모 불러오기 또는 이벤트 스트림</td>\n</tr>\n<tr>\n<td>주요 사용처</td>\n<td>웹 애플리케이션을 통한 최종 사용자</td>\n<td>의사결정 지원을 위한 내부 분석가</td>\n</tr>\n<tr>\n<td>데이터 표현</td>\n<td>데이터의 최신 상태</td>\n<td>시간이 지나며 일어난 이벤트 이력</td>\n</tr>\n<tr>\n<td>데이터셋 크기</td>\n<td>기가바이트에서 테라바이트</td>\n<td>테라바이트에서 페타바이트</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"데이터-웨어하우징\" style=\"position:relative;\">데이터 웨어하우징<a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%9B%A8%EC%96%B4%ED%95%98%EC%9A%B0%EC%A7%95\" aria-label=\"데이터 웨어하우징 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>OLTP 시스템은 대개 사업 운영에 대단히 중요하기 때문에 높은 가용성과 낮은 지연 시간의 트랜잭션 처리를 기대한다.</li>\n<li>데이터 웨어하우스는 분석가들이 OLTP 작업에 영향을 주지 않고 마음껏 질의할 수 있는 개별 데이터베이스이다.</li>\n<li>데이터 웨어하우스는 회사 내의 모든 다양한 OLTP 시스템에 있는 데이터의 읽기 전용 복사본이다.</li>\n<li>데이터는 OLTP 데이터베이스에서 주지적인 데이터 덤프나 지속적인 갱신 스트림을 사용해 추출하고 분석 친화적인 스키마로 변환하고 깨끗하게 정리한 다음 데이터 웨어하우스에 적재한다. 이런 과정을 <code class=\"language-text\">ETL(Extract-Transform-Load)</code>이라한다.</li>\n</ul>\n<h3 id=\"OLTP-데이터베이스와-데이터-웨어하우스의-차이점\" style=\"position:relative;\">OLTP 데이터베이스와 데이터 웨어하우스의 차이점<a href=\"#OLTP-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%99%80-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%9B%A8%EC%96%B4%ED%95%98%EC%9A%B0%EC%8A%A4%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"OLTP 데이터베이스와 데이터 웨어하우스의 차이점 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>SQL은 일반적으로 분석 질의해 적합하기 때문에 데이터 웨어하우스의 데이터 모델은 가장 일반적인 관계형 모델을 사용한다.</li>\n<li>표면적으로 데이터 웨어하수으와 관계형 OLTP 데이터베이스 둘 다 SQL 질의 인터페이스를 지원하기 때문에 비슷해 보인다.</li>\n<li>하지만 각각 매우 다른 질의 패턴에 맞게 최적화됐기 때문에 시스템 내부는 완전히 다르다.</li>\n<li>데이터 웨어하우스의 대표적인 예로 SQL 온 하둡, 아파치 하이브, 스파크 SQL, 클라우데라 임팔라, 페이스북 프레스토, 아파치 타조, 아파치 드릴 등이 있다.</li>\n</ul>","fields":{"slug":"/ch3/","thumbnail":null},"frontmatter":{"date":"January 14, 2022","update":"Jan 14, 2022","title":"3장 - 저장소와 검색","description":null,"tags":["데이터 중심 애플리케이션 설계"],"thumbnail":null}},{"excerpt":"데이터  모델은 소프트웨어가 할 수 있는 일과 할 수 없는 일에 지대한 영향을 주므로 애플리케이션에 적합한 데이터 모델을 선택하는 작업은 상당히 중요하다. 관계형 모델과 문서 모델 오늘날 가장 장 알려진 데이터 모델은 관계형 모델을 기반으로 한 SQL 이다. 데이터는 관계(relation) 로 구성되고 각 관계는 순서 없는 튜플(tuple) 의 모음이다.…","html":"<p>데이터  모델은 소프트웨어가 할 수 있는 일과 할 수 없는 일에 지대한 영향을 주므로 애플리케이션에 적합한 데이터 모델을 선택하는 작업은 상당히 중요하다.</p>\n<!-- more -->\n<h1>관계형 모델과 문서 모델</h1>\n<ul>\n<li>오늘날 가장 장 알려진 데이터 모델은 관계형 모델을 기반으로 한 SQL 이다.</li>\n<li>데이터는 <strong>관계(relation)</strong> 로 구성되고 각 관계는 순서 없는 <strong>튜플(tuple)</strong> 의 모음이다.</li>\n</ul>\n<h3 id=\"NoSQL의-탄생\" style=\"position:relative;\">NoSQL의 탄생<a href=\"#NoSQL%EC%9D%98-%ED%83%84%EC%83%9D\" aria-label=\"NoSQL의 탄생 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>2010년대에 NoSQL은 관계형 모델의 우위를 뒤집으려는 가장 최신 시도이다.</li>\n<li>\n<p>NoSQL 데이터베이스를 채택한 데는 다음과 같은 다양한 원동력이 있다.</p>\n<ul>\n<li>대규모 데이터셋이나 매우 높은 쓰기 처리량 달성을 관계형 데이터베이스보다 쉽게 할 수 있는 뛰어난 확장성의 필요</li>\n<li>상용 데이터베이스 제품보다 무료 오픈소스 소프트웨어에 대한 선호도 확산</li>\n<li>관계형 모델에서 지원하지 않는 특수 질의 동작</li>\n<li>관계형 스키마 제한에 대한 불만과 더욱 동적이고 표현력이 풍부한 데이터 모델에 대한 바람</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"객체-관계형-불일치\" style=\"position:relative;\">객체 관계형 불일치<a href=\"#%EA%B0%9D%EC%B2%B4-%EA%B4%80%EA%B3%84%ED%98%95-%EB%B6%88%EC%9D%BC%EC%B9%98\" aria-label=\"객체 관계형 불일치 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>객체지향 프로그램에서 데이터를 관계형 테이블에 저장하려면 애플리케이션 코드와 데이터베이스 모델 객체 사이에 거추장스러운 전환 계층이 필요하다.</li>\n<li>이런 모델 사이의 분리를 <strong>임피던스 불일치(impedance mismatch)</strong> 라고 부른다.</li>\n<li>관계형 스키마로 표현한 이력서 예시</li>\n<li>이력서 같은 데이터 구조는 모든 내용을 갖추고 있는 문서라서 JSON 표현에 매우 적합하다.</li>\n<li>몽고DB, 링싱크DB, 카우치DB, 에스프레소 같은 문서 지향 데이터베이스는 JSON 데이터 모델을 지원한다.</li>\n</ul>\n<h3 id=\"다대일과-다대다-관계\" style=\"position:relative;\">다대일과 다대다 관계<a href=\"#%EB%8B%A4%EB%8C%80%EC%9D%BC%EA%B3%BC-%EB%8B%A4%EB%8C%80%EB%8B%A4-%EA%B4%80%EA%B3%84\" aria-label=\"다대일과 다대다 관계 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>관계형 데이터베이스 예시 그림에서 <code class=\"language-text\">region_id</code> 와 <code class=\"language-text\">industry_id</code>는 평문인 <code class=\"language-text\">“그레이터 시애틀 구역”</code> 과 <code class=\"language-text\">“자선활동”</code>이 아닌 ID로 주어졌다. 왜 일까?</li>\n<li>\n<p>지역과 업계의 표준 목록으로 드롭다운 리스트나 자동 완성 기능을 만들어 사용자가 선택하게 하는 데는 다음과 같은 장점이 있다.</p>\n<ul>\n<li>프로필 간 일관된 스타일과 철자</li>\n<li>모호함 회피 <code class=\"language-text\">(예를 들어 이름이 같은 여러 도시가 있는 경우)</code></li>\n<li>갱신의 편의성, 이름이 한 곳에만 저장되므로 이름을 변경해야 하는 경우 전반적으로 갱신하기 쉽다.</li>\n<li>현지화 지원, 사이트를 다른 언어로 번역할 때 표준 목록을 현지화해 지역과 업계 사이트를 보는 사람의 언어로 표시할 수 있다.</li>\n<li>더 나은 검색</li>\n</ul>\n</li>\n<li>\n<p>ID나 텍스트 문자열의 저장 여부는 중복의 문제이다.</p>\n<ul>\n<li>ID를 사용하게 되면 한 곳에만 저장하고 다른 곳에서 모두 참조를 한다.</li>\n<li>텍스트를 직접 저장한다면 그것을 사용하는 모든 레코드에서 정보를 중복해서 저장하게 된다.</li>\n</ul>\n</li>\n<li>\n<p>중복된 데이터를 정규화하려면 <strong>다대일 관계</strong>가 필요하다.</p>\n<ul>\n<li>관계형 데이터베이스는 조인이 쉽기 때문에 ID로 다른 테이블의 로우를 참조하는 방식은 일반적이다.</li>\n<li>문서 모델에서 조인에 대한 지원이 약하기 때문에 다대일 관계는 적합하지 않다.</li>\n</ul>\n</li>\n<li>\n<p>애플리케이션의 초기 버전이 조인 없는 문서 모델에 적합하더라도 애플리케이션 기능이 추가하면서 데이터는 점차 상호 연결되는 경향이 있다.</p>\n<ul>\n<li>이력서의 새로운 기능으로 한 사용자가 또 다른 사용자를 위해 추천서를 작성하는 기능을 넣는다고 해보자.</li>\n<li>추천서는 추천받은 사용자 이력서에는 추천인의 이름과 사진이 함께 보여진다.</li>\n<li>추천인이 자신의 프로필을 갱신한다면 추천인이 작성한 모든 추천서 역시 갱신되어야 한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"문서-데이터베이스는-역사를-반복하고-있나\" style=\"position:relative;\">문서 데이터베이스는 역사를 반복하고 있나?<a href=\"#%EB%AC%B8%EC%84%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EB%8A%94-%EC%97%AD%EC%82%AC%EB%A5%BC-%EB%B0%98%EB%B3%B5%ED%95%98%EA%B3%A0-%EC%9E%88%EB%82%98\" aria-label=\"문서 데이터베이스는 역사를 반복하고 있나 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>1970년대 비지니스 데이터를 처리를 위해 가장 많이 사용한 데이터베이스는 <strong>정보 관리 시스템(IMS)</strong> 로 지금의 JSON 모델과 놀랍게도 비슷하다.</li>\n<li>문서 데이터베이스처럼 IMS도 일대다 관계에서는 잘 동작한다.</li>\n<li>하지만 다대다 관계표현은 어렵고 조인은 지원하지 않는다.</li>\n<li>이러한 계층 모델의 한계를 해결하기 위해 관계형 모델과 네트워크 모델이 나왔다.</li>\n</ul>\n<h3 id=\"네트워크-모델\" style=\"position:relative;\">네트워크 모델<a href=\"#%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EB%AA%A8%EB%8D%B8\" aria-label=\"네트워크 모델 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>계층 모델의 트리 구조에서 모든 레코드는 정확하게 하나의 부모가 있다.</li>\n<li>네트워크 모델에서 레코드는 다중 부모가 있을 수 있다.</li>\n<li>네트워크 모델에서 레코드 간 연결은 프로그래밍 언어의 포인터와 유사하다.</li>\n<li>레코드에 접근하는 유일한 방법은 최상위 레코드에서부터 연속된 연결 경로를 따르는 방법이다.</li>\n<li>데이터베이스 질의와 갱신을 위한 코드가 복잡하고 유연하지 못한 문제가 있었다.</li>\n</ul>\n<h3 id=\"관계형-모델\" style=\"position:relative;\">관계형 모델<a href=\"#%EA%B4%80%EA%B3%84%ED%98%95-%EB%AA%A8%EB%8D%B8\" aria-label=\"관계형 모델 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>관계형 모델이 하는 일은 알려진 모든 데이터를 배치하는 것이다.</li>\n<li>관계형 데이터베이스에서 질의 최적화기(query optimizer)는  질의의 어느 부분을 어떤 순서로 실행할지를 결정하고 사용할 색인을 자동으로 결정한다.</li>\n<li>질의 최적화기를 한번 만들면 데이터베이스를 사용하는 모든 애플리케이션이 혜택을 받을 수 있다.</li>\n</ul>\n<h3 id=\"문서-데이터베이스와의-비교\" style=\"position:relative;\">문서 데이터베이스와의 비교<a href=\"#%EB%AC%B8%EC%84%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%99%80%EC%9D%98-%EB%B9%84%EA%B5%90\" aria-label=\"문서 데이터베이스와의 비교 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>문서 데이터베이스는 별도의 테이블이 아닌 상위 레코드 내에 중첩된 레코드를 저장한다.</li>\n<li>하지만 다대일과 다대다 관계를 표현할 때 관계형 데이터베이스와 문서 데이터베이스는 근본적으로 다르지 않다. 둘 다 관련 항목은 고유한 식별자로 참조한다.</li>\n<li>관계형 모델에서는 <strong>외래 키</strong>라 부르고 문서 모델에서는 <strong>문서 참조</strong>라 부른다.</li>\n</ul>\n<h3 id=\"관계형-데이터베이스와-오늘날의-문서-데이터베이스\" style=\"position:relative;\">관계형 데이터베이스와 오늘날의 문서 데이터베이스<a href=\"#%EA%B4%80%EA%B3%84%ED%98%95-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%EC%99%80-%EC%98%A4%EB%8A%98%EB%82%A0%EC%9D%98-%EB%AC%B8%EC%84%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4\" aria-label=\"관계형 데이터베이스와 오늘날의 문서 데이터베이스 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>문서 데이터 모델을 선호하는 이유는 스키마 유연성, 지역성에 기인한 더 나은 성능때문이고, 일부 애플리케이션의 경우 애플리케이션에서 사용하는 데이터 구조와 더 가깝기 때문이다.</li>\n<li>관계형 모델은 조인, 다대일, 다대다 관계를 더 잘 지원함으로써 문서 데이터 모델에 대항한다.</li>\n</ul>\n<h3 id=\"어떤-데이터-모델이-애플리케이션-코드를-더-간단하게-할까\" style=\"position:relative;\">어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 할까?<a href=\"#%EC%96%B4%EB%96%A4-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%AA%A8%EB%8D%B8%EC%9D%B4-%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98-%EC%BD%94%EB%93%9C%EB%A5%BC-%EB%8D%94-%EA%B0%84%EB%8B%A8%ED%95%98%EA%B2%8C-%ED%95%A0%EA%B9%8C\" aria-label=\"어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 할까 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>애플리케이션에서 데이터가 문서와 비슷한 구조<code class=\"language-text\">(일대다 관계 트리로 보통 한 번에 전체 트리를 적재)</code>라면 문서 모델을 사용하는 것이 좋다.</li>\n<li>문서 모델의 제한은 문서 내 중첩 항목을 바로 참조할 수 없어서 <code class=\"language-text\">\"사용자 251의 직위 목록의 두 번쨰 항목\"</code>과 같이 표현해야 한다.</li>\n<li><strong>애플리케이션에서 다대다 관계를 사용한다면 관계형 모델이 적합하다.</strong></li>\n<li>비정규화로 조인의 필요성이 줄이기가 가능하지만 애플리케이션 코드는 비정규화된 데이터의 일관성을 유지하기 위해 추가 작업을 해야한다.</li>\n<li>일반적으로 어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 만드는지 말할 수 없다.</li>\n<li>상호 연결이 많은 데이터의 경우 그래프 모델은 매우 자연스럽다.</li>\n</ul>\n<h3 id=\"문서-모델에서의-스키마-유연성\" style=\"position:relative;\">문서 모델에서의 스키마 유연성<a href=\"#%EB%AC%B8%EC%84%9C-%EB%AA%A8%EB%8D%B8%EC%97%90%EC%84%9C%EC%9D%98-%EC%8A%A4%ED%82%A4%EB%A7%88-%EC%9C%A0%EC%97%B0%EC%84%B1\" aria-label=\"문서 모델에서의 스키마 유연성 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>대부분의 문서 데이터베이스와 관계형 데이터베이스에서 지원하는 JSON은 문서의 데이터에 어떤 스키마를 강요하지 않는다.</li>\n<li>스키마가 없다는 뜻은 임의의 키와 값을 문서에 추가할 수 있고 읽을 때 클라이언트는 문서에 포함된 필드의 존재 여부를 보장하지 않는다는 의미다.</li>\n<li>문서 데이터베이스는 종종 스키마리스(schemaless)로 불리지만 데이터베이스가 이를 강요하지 않을 뿐, 암묵적인 스키마<code class=\"language-text\">(쓰기 스키마, 읽기 스키마)</code>가 존재한다.</li>\n<li>읽기 스키마는 프로그래밍 언어에서 동적 타입 확인과 유사하고 쓰기 스키마는 정적 타입 확인과 비슷하다.</li>\n<li>읽기 스키마 접근 방식은 컬렉션 안의 항목이 어떤 이유로 모든 동일한 구조가 아닐 때 유용하다.</li>\n</ul>\n<h3 id=\"정리\" style=\"position:relative;\">정리<a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>역사적으로 데이터를 하나의 큰 트리(계층 모델)로 표현하려고 노력했지만 다대다 관계를 표현하기에는 트리 구조가 적절하지 않았다.</li>\n<li>이 문제를 해결하기 위해 관계형 모델이 고안됐다.</li>\n<li>\n<p>최근에는 관계형 모델에도 적합하지 않은 애플리케이션이 있다는 사실을 발견했고 새롭게 등장한 비관계형 데이터저장소인 NoSQL은 다음과 같은 두 가지 주요 갈래가 있다.</p>\n<ul>\n<li><code class=\"language-text\">문서 데이터베이스</code>는 데이터가 문서 자체에 포함돼 있으면서 하나의 문서와 다른 문서 간 관계가 거의 없는 사용 사례를 대상으로 한다.</li>\n<li><code class=\"language-text\">그래프 데이터베이스</code>는 문서 데이터베이스와는 정반대로 모든 것이 잠재적으로 관련 있다는 사용 사례를 대상으로 한다.</li>\n</ul>\n</li>\n<li>한 모델을 다른 모델로 흉내 낼 수 있지만, 대부분 엉망이다. 각기 목적에 맞는 다양한 시스템을 보유해야 된다.</li>\n<li>문서 및 그래프 데이터베이스가 가진 공통점 중 하나는 일반적으로 저정할 데이터를 위한 스키마를 강제하지 않아 변화하는 요구사항에 맞춰 애플리케이션을 쉽게 변경할 수 있다는 점이다.</li>\n</ul>","fields":{"slug":"/ch2/","thumbnail":null},"frontmatter":{"date":"January 10, 2022","update":"Jan 10, 2022","title":"2장 - 데이터 모델과 질의 언어","description":null,"tags":["데이터 중심 애플리케이션 설계"],"thumbnail":null}},{"excerpt":"일반적으로 데이터 중심 애플리케이션은 다음을 필요로 한다. 구동 애플리케이션이나 다른 애플리케이션에서 나중에 다시 데이터를 찾을 수 있게 데이터를 저장 (데이터베이스) 읽기 속도 향상을 위해 값비싼 수행결과를 기억 (캐시) 사용자가 키워드로 데이터를 검색하거나 다양한 방법으로 필터링 할 수 있게 제공 (검색 색인, search Index) 비동기 처리를 …","html":"<p>일반적으로 데이터 중심 애플리케이션은 다음을 필요로 한다.</p>\n<ul>\n<li>구동 애플리케이션이나 다른 애플리케이션에서 나중에 다시 데이터를 찾을 수 있게 데이터를 저장 <strong>(데이터베이스)</strong></li>\n<li>읽기 속도 향상을 위해 값비싼 수행결과를 기억 <strong>(캐시)</strong></li>\n<li>사용자가 키워드로 데이터를 검색하거나 다양한 방법으로 필터링 할 수 있게 제공 <strong>(검색 색인, search Index)</strong></li>\n<li>비동기 처리를 위해 다른 프로세스로 메시지 보내기 <strong>(스트림 처리, stream processing)</strong></li>\n<li>주기적으로 대량의 누적된 데이터를 분석 <strong>(일괄 처리, batch Processing)</strong> </li>\n</ul>\n<p>애플리케이션마다 요구사항이 다르기 때문에 어떤 도구와 어떤 접근 방식이 수행 중인 작업에 가장 적합한지 생각해야 한다.</p>\n<!-- more -->\n<h1>신뢰성(Reliability)</h1>\n<p>하드웨어나 소프트웨어 결함, 인적 오류(humman error) 같은 역경에 직면하더라도 시스템은 지속적으로 올바르게 동작해야 한다.</p>\n<ul>\n<li>잘못될 수 있는 일을 <strong>결함(fault)</strong> 이라 부른다. 결함을 예측하고 대처할 수 있는 시스템을 <strong>내결함성(fault-tolerant)</strong> 또는 <strong>탄력성(resilient)</strong> 을 지녔다고 말한다.</li>\n<li>모든 종류의 결함을 견딜 수 있는 시스템을 만드는 것은 실현 가능하지 않다. 따라서 특정 유형의 <strong>결합 내성</strong>에 대해서만 이야기하는 것이 가능하다.</li>\n<li>결합은 장애(failure)와 동일하지 않다. 결함은 사양에서 벗어난 시스템의 한 구성 요소로 정의되지만, <strong>장애</strong>는 사용자에게 필요한 서비스를 제공하지 못하고 시스템 전체가 멈춘 경우다.</li>\n<li>결함 확률을 0으로 줄이는 것은 불가능하다. 따라서 결함으로 인해 장애가 발생하지 않게끔 내결함성 구조를 설계하는 것이 가장 좋다.</li>\n</ul>\n<h3 id=\"하드웨어-결함\" style=\"position:relative;\">하드웨어 결함<a href=\"#%ED%95%98%EB%93%9C%EC%9B%A8%EC%96%B4-%EA%B2%B0%ED%95%A8\" aria-label=\"하드웨어 결함 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>하드디스크가 고장 나고, 램의 고장, 대규모 정전과 같은 결합을 말한다.</p>\n<ul>\n<li>각 해드웨어 구성 요소에 중복을 추가하는 방법이 일반적이다.</li>\n</ul>\n<h3 id=\"소프트웨어-결함\" style=\"position:relative;\">소프트웨어 결함<a href=\"#%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4-%EA%B2%B0%ED%95%A8\" aria-label=\"소프트웨어 결함 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>소프트웨어 결함을 유발하는 버그는 특정 상황에 의해 발생하기 전까지 오랫동안 나타나지 않는다.</li>\n<li>소프트웨어의 체계적 오류 문제는 신속한 해결책이 없다. 시스템의 가정과 상호작용에 대해 주의 깊게 생각하기, 빈틈없는 테스트, 프로세스 격리, 죽은 프로세스의 재시작 허용, 프로덕션 환경의 시스템 동작의 측정, 모니터링, 분석하기와 같은 여러 작은 일들이 문제 해결에 도움을 줄 수 있다.</li>\n</ul>\n<h3 id=\"인적-오류\" style=\"position:relative;\">인적 오류<a href=\"#%EC%9D%B8%EC%A0%81-%EC%98%A4%EB%A5%98\" aria-label=\"인적 오류 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>대규모 인터넷 서비스에 대한 한 연구에 따르면 운영자의 설정 오류가 중단의 주요 원인이다.</li>\n<li>\n<p>최고의 시스템은 다양한 접근 방식을 결합한다.</p>\n<ul>\n<li>오류의 가능성을 최소화하는 방향으로 설계해라. 잘 설계된 추상화, API, 관리 인터페이스를 사용하면</li>\n<li>실제 데이터를 사용해 안전하게 살펴보고 실험할 수 있지만 실제 사용자에게는 영향이 없는 비 프로덕션 샌드박스를 제공하라</li>\n<li>단위 테스트부터 전체 시스템 통합 테스트와 수동 테스트까지 모든 수준에서 철저하게 테스트하라.</li>\n<li>장애 발생의 영향을 최소화하기 위해 인적 오류를 빠르게 쉽게 복구할 수 있게 하라.</li>\n<li>성능 지표와 오류율 같은 상세하고 명확한 모니터링 대책을 마련하라.</li>\n<li>조작 교육과 실습을 시행하라.</li>\n</ul>\n</li>\n</ul>\n<h1>확장성(Scalability)</h1>\n<p>시스템의 데이터 양, 트래픽 양, 복잡도가 증가하면서 이를 처리할 수 있어야 한다.</p>\n<h3 id=\"부하-기술하기\" style=\"position:relative;\">부하 기술하기<a href=\"#%EB%B6%80%ED%95%98-%EA%B8%B0%EC%88%A0%ED%95%98%EA%B8%B0\" aria-label=\"부하 기술하기 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>부하는 <strong>부하 매개변수(load parameter)</strong> 라 부르는 몇 개의 숫자로 나타낼 수 있다. <strong>웹 서버의 초당 요청 수, 데이터베이스 읽기 대 쓰기 비율, 대화방의 동시 활성 사용자, 캐시 적중률</strong> 등이 될 수 있다.</p>\n<h3 id=\"트위터의-예\" style=\"position:relative;\">트위터의 예<a href=\"#%ED%8A%B8%EC%9C%84%ED%84%B0%EC%9D%98-%EC%98%88\" aria-label=\"트위터의 예 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>\n<p>트위터의 주요 두 가지 동작은 다음과 같다.</p>\n<ul>\n<li><code class=\"language-text\">트윗 작성 : 사용자는 팔로워에게 새로운 메시지를 개시할 수 있다.</code></li>\n<li><code class=\"language-text\">홈 타임라인 : 사용자는 팔로우한 사람이 작성한 트윗을 볼 수 있다.</code></li>\n</ul>\n</li>\n<li>트위터의 확장성 문제는 트윗 작성이 아닌 팔로우 한 사용자들의 트윗의 수신 문제이다.</li>\n<li>\n<p>이 두가지 동작을 구현하는 방법은 크게 두 가지이다.</p>\n<ul>\n<li>\n<p>접근 방식 1</p>\n<ul>\n<li>사용자가 자신의 홈 타임라인을 요청하면, 팔로우하는 모든 사람을 찾고, 이 사람들의 모든 트윗을 찾아 시간순으로 정렬하도록 쿼리한다.</li>\n</ul>\n</li>\n<li>\n<p>접근 방식 2</p>\n<ul>\n<li>각 수신 사용자용 홈 타인라인 캐시를 유지한다. 사용자가 트우잇을 작성하면 해당 사용자를 팔로우하는 사람을 모두 찾고 각자의 홈 타임라인 캐시에 새로운 트윗을 삽입한다.</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>평균적으로 트윗 게시 요청량이 홈 타임라인 읽기 요청량에 비해 수백 배 적기 때문에 접근 방식2가 훨씬 잘 작동한다.</li>\n<li>팔로워가 매우 많다면, 단일 트윗을 쓰기하는데 3천만 건 이상의 쓰기 요청이 될 수 있다.</li>\n<li>트위터 사례에서 사용자당 팔로워 분포는 핵심 부하 매개변수가 된다.</li>\n<li>트위터는 대부분의 사용자 트윗은 <code class=\"language-text\">접근 방식(2)</code>를 사용하고, 팔로워 수가 매우 많은 소수 사용자는 <code class=\"language-text\">접근 방식(1)</code>처럼 읽는 시점에 사용자의 홈 타임라인에 합친다.</li>\n</ul>\n<h3 id=\"성능-기술하기\" style=\"position:relative;\">성능 기술하기<a href=\"#%EC%84%B1%EB%8A%A5-%EA%B8%B0%EC%88%A0%ED%95%98%EA%B8%B0\" aria-label=\"성능 기술하기 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>시스템 부하를 기술하면 부하가 증가할 때 어떤 일이 일어나는지 조사할 수 있다.</p>\n<ul>\n<li>부하 매개 변수를 증가시키고, 시스템 자원은 변경하지 않고 유지하면 시스템 성능은 어떻게 영향을 받을까?</li>\n<li>부하 매개변수를 증가시켰을 때 성능이 변하지 않고 유지되길 원한다면 얼마나 많이 자원을 늘려야할까?</li>\n<li>\n<p>위 두 질문 모두 성능 수치가 필요하다.</p>\n<ul>\n<li>일괄 처리 시스템의 관심사는 <strong>처리량(throughput)</strong></li>\n<li>온라인 시스템의 관심사는 <strong>응답 시간(response time)</strong></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"응답시간은-일반적으로-평균보다는-백분위percentile를-사용하는-편이-더-좋다\" style=\"position:relative;\">응답시간은 일반적으로 평균보다는 백분위(percentile)를 사용하는 편이 더 좋다.<a href=\"#%EC%9D%91%EB%8B%B5%EC%8B%9C%EA%B0%84%EC%9D%80-%EC%9D%BC%EB%B0%98%EC%A0%81%EC%9C%BC%EB%A1%9C-%ED%8F%89%EA%B7%A0%EB%B3%B4%EB%8B%A4%EB%8A%94-%EB%B0%B1%EB%B6%84%EC%9C%84percentile%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%ED%8E%B8%EC%9D%B4-%EB%8D%94-%EC%A2%8B%EB%8B%A4\" aria-label=\"응답시간은 일반적으로 평균보다는 백분위percentile를 사용하는 편이 더 좋다 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li>사용자가 보통 얼마나 오랫동안 기다려야 하는지 알고 싶다면 중앙값(p50)이 좋은 지표다.</li>\n<li>특이 값이 얼마나 좋지 않는지 알아보려면 상위 백분위를 살펴보는 것이 좋다.</li>\n<li><code class=\"language-text\">95분위, 99분위, 99.9분위(p55, p99, p999)</code>가 일반적이다.</li>\n<li>예를 들어, 95분위 응답시간이 1.5초라면 100개의 요청 중 95개는 1.5초 미만이고, 5개는 1.5초보다 더 걸린다.</li>\n<li><strong>꼬리 지연 시간(tail latency)</strong> 으로 알려진 상위 백분위 응답 시간은 서비스의 사용자 경험에 직접 영향을 주기 때문에 영향을 준다.</li>\n<li>아마존은 응답 시간 요구사항을 99.9분위로 기술한다. 왜냐하면 느린 요청을 경험한 고객들이 더 많은 데이터를 가지고 있고 VIP 이기 때문이다.</li>\n</ul>\n<h3 id=\"부하-대응-접근-방식\" style=\"position:relative;\">부하 대응 접근 방식<a href=\"#%EB%B6%80%ED%95%98-%EB%8C%80%EC%9D%91-%EC%A0%91%EA%B7%BC-%EB%B0%A9%EC%8B%9D\" aria-label=\"부하 대응 접근 방식 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<ul>\n<li><strong>용량 확장(scaling up, 수직 확장)</strong> : 좀 더 강력한 장비로 이동</li>\n<li><strong>규모 확장(scaling out, 수평 확장)</strong> : 다수의 낮은 사양 장비에 부하를 분산 → 비공유 아키텍처라 부름</li>\n<li>\n<p>범용적이고 모든 상황에 맞는 마법의 확장 아키텍처는 없다.</p>\n<ul>\n<li>예를 들어 크기가 1KB인 초당 100,000건의 요청을 처리하도록 설계된 시스템과 크기가 2GB인 분당 3건의 요청을 처리하기 위해 설계된 시스템은 서로 같은 데이터 처리량이라 해도 매우 다르다.</li>\n</ul>\n</li>\n<li>아키텍처를 결정하는 요소는 <strong>읽기의 양, 쓰기의 양, 저장할 데이터의 양, 데이터 복잡도, 응답 시간 요구사항, 접근 패턴 등이 있다.</strong></li>\n<li>특정 애플리케이션에 적합한 확장성을 갖춘 아키텍처는 주요 동작이 무엇이고 잘 하지 않는 동작이 무엇인지에 대한 가정을 바탕으로 구축한다. 이 가정이 곧 <strong>부하 매개변수</strong>가 된다.</li>\n<li>부가 매개변수의 대한 가정이 잘못되면 엔지니어링 노력은 헛수고가 되고 최악의 경우 역효과를 낳는다.</li>\n<li>확장성을 갖춘 아키텍처는 보통 익숙한 패턴으로 나열된 범용적인 구성 요소로 구축된다.</li>\n</ul>\n<h1>3. 유지보수성(Maintainability)</h1>\n<ul>\n<li>시간이 지남에 따라 여러 다양한 사람들이 시스템 상에서 작업할 것이기 때문에 모든 사용자가 시스템 상에서 생산적으로 작업할 수 있게 해야한다.</li>\n<li>\n<p>소프트웨어 비용의 대부분은 초기 개발이 아니라 지속해서 이어지는 유지보수에 들어간다.</p>\n<ul>\n<li>버그 수정, 시스템 운영 유지, 장애 조사, 새로운 플랫폼 적응, 새 사용 사례를 위한 변경, 기술 채무 상환, 새로운 기능 추가 등이 있다.</li>\n</ul>\n</li>\n<li>유지보수 고통을 최소화하기 위해 소프트웨어 시스템 설계 원칙은 다음 세 가지다.</li>\n</ul>\n<h3 id=\"1-운용성operability\" style=\"position:relative;\">1. 운용성(operability)<a href=\"#1-%EC%9A%B4%EC%9A%A9%EC%84%B1operability\" aria-label=\"1 운용성operability permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<blockquote>\n<p>운영팀이 시스템을 원활하게 운영할 수 있게 쉽게 만들어라.</p>\n</blockquote>\n<ul>\n<li>\n<p>좋은 운영성이란 동일하게 반복되는 태스크를 쉽게 수행하게끔 만들어 운영팀이 고부가가치 활동에 노력을 집중한다는 의미이다.</p>\n<ul>\n<li>좋은 모니터링으로 런타임 동작과 시스템의 내부의 대한 가시성 제공</li>\n<li>표준 도구를 이용해 자동화와 통합을 위한 우수한 자원을 제공</li>\n<li>개별 장비 의존성을 회피, 유지보수를 위해 장비를 내리더라도 시스템 전체에 영향을 주지 않고 계속해서 운영 가능해야 함</li>\n<li>좋은 문서와 이해하기 쉬운 운영 모델 제공</li>\n<li>만족할 만한 기본 동작을 제공하고, 필요할 때 기본값을 다시 정의할 수 있는 자유를 관리자에게 부여</li>\n<li>적절하게 자기 회복이 가능할 뿐 아니라 필요에 따라 관리자가 시스템 상태를 수동으로 제어할 수 있게 함</li>\n<li>예측 가능하게 동작하고 예기치 않은 상황을 최소화함</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-단순성simplicity\" style=\"position:relative;\">2. 단순성(simplicity)<a href=\"#2-%EB%8B%A8%EC%88%9C%EC%84%B1simplicity\" aria-label=\"2 단순성simplicity permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<blockquote>\n<p>시스템에서 복잡도를 최대한 제거해 새로운 엔지니어가 시스템을 이해하기 쉽게 만들어라.</p>\n</blockquote>\n<ul>\n<li>소규모 소프트웨어 프로젝트에서는 간단하고 표현이 풍부한 코드로 말끔하게 시스템을 작성할 수 있지만 프로젝트가 커짐에 따라 시스템은 매우 복잡하고 이해하기 어려워 진다.</li>\n<li>\n<p>복잡도는 다양한 증상으로 나타난다.</p>\n<ul>\n<li>상태 공간의 급증, 모듈 간 강한 커플링, 복잡한 의존성, 일관성 없는 네이밍과 용어, 성능 문제 해결을 목표로 한 해킹, 임시방편으로 문제를 해결한 특수 사례 등</li>\n</ul>\n</li>\n<li>우발적 복잡도란 소프트웨어가 풀어야 할 문제에 내제하지 않고 구현에서만 발생하는 것으로 정의된다.</li>\n<li>우발적 복잡도를 제거하기 위한 최상의 도구는 <strong>추상화</strong>다.</li>\n<li>좋은 추상화는 다른 다양한 애플리케이션에서도 사용 가능하다. 이런 재사용은 비슷한 기능을 재구현하는 것보다 효율적이고 고품질 소프트웨어로 이어진다.</li>\n</ul>\n<h3 id=\"3-발전성evolvability\" style=\"position:relative;\">3. 발전성(evolvability)<a href=\"#3-%EB%B0%9C%EC%A0%84%EC%84%B1evolvability\" aria-label=\"3 발전성evolvability permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<blockquote>\n<p>엔지니어가 이후에 시스템을 쉽게 변경할 수 있게 하라. 그래야 요구사항 변경 같은 예기치 않은 사용 사례를 적용하기가 쉽다.</p>\n</blockquote>\n<ul>\n<li>조직 프로세스 측면에서 <strong>애자일</strong> 작업 패턴은 변화에 적응하기 위한 프레임워크를 제공한다.</li>\n<li>TDD, 리팩토링 같이 자주 변화하는 환경에서 소프트웨어를 개발할 때 도움이 되는 기술 도구와 패턴을 개발하고 있다.</li>\n</ul>\n<h1>정리</h1>\n<ul>\n<li>애플리케이션이 유용하려면 다양한 요구사항을 충족시켜야 한다.</li>\n<li><code class=\"language-text\">기능적 요구사항</code> :  여러 방법으로 데이터를 저장하고 조회하고 검색하고 처리하게끔 허용하는 작업과 같이 해야하는 일</li>\n<li><code class=\"language-text\">비기능적 요구사항</code> : 보안, 신뢰성, 법규 준수, 확장성, 호환성, 유지보수성과 같은 일반 속성</li>\n<li>신뢰성은 결함이 발생해도 시스템이 올바르게 동작하게 만든다는 의미이다.</li>\n<li>확장성은 부하가 증가해도 좋은 성능을 유지하기 위한 전략을 의미한다.</li>\n<li>유지보수성에는 시스템에서 작업하는 엔지니어와 운영 팀의 삶을 개선하는데 있다.</li>\n</ul>","fields":{"slug":"/ch1/","thumbnail":null},"frontmatter":{"date":"January 05, 2022","update":"Jan 05, 2022","title":"1장 - 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션","description":null,"tags":["데이터 중심 애플리케이션 설계"],"thumbnail":null}}]},"totalMarkdown":{"group":[{"fieldValue":"AWS","totalCount":2},{"fieldValue":"JPA","totalCount":1},{"fieldValue":"Java","totalCount":10},{"fieldValue":"Tomcat","totalCount":2},{"fieldValue":"kernel","totalCount":1},{"fieldValue":"데이터 중심 애플리케이션 설계","totalCount":8},{"fieldValue":"데이터베이스","totalCount":2},{"fieldValue":"디자인 패턴","totalCount":3},{"fieldValue":"레디스","totalCount":1},{"fieldValue":"스프링","totalCount":5},{"fieldValue":"실무로 배우는 시스템 성능 최적화","totalCount":7},{"fieldValue":"카프카","totalCount":3}],"nodes":[{"fields":{"slug":"/java-synchronized/"}},{"fields":{"slug":"/mysql-transaction-lock/"}},{"fields":{"slug":"/socket_internal/"}},{"fields":{"slug":"/java-nio-selector/"}},{"fields":{"slug":"/java-nio-channel/"}},{"fields":{"slug":"/spring-core-container/"}},{"fields":{"slug":"/tomcat-connection/"}},{"fields":{"slug":"/java-nio-buffer/"}},{"fields":{"slug":"/socket_option/"}},{"fields":{"slug":"/tomcat/"}},{"fields":{"slug":"/java-concurrency-lock/"}},{"fields":{"slug":"/java-concurrency-deadlock/"}},{"fields":{"slug":"/java-concurrency-executor/"}},{"fields":{"slug":"/java-concurrency-model/"}},{"fields":{"slug":"/java-concurrency/"}},{"fields":{"slug":"/mysql-primary-key-design/"}},{"fields":{"slug":"/ehcache3/"}},{"fields":{"slug":"/jpa-slow-cause/"}},{"fields":{"slug":"/redis-event-notifications/"}},{"fields":{"slug":"/spring-cache-hierarchy/"}},{"fields":{"slug":"/java-collection-wrapper/"}},{"fields":{"slug":"/Spring Cloud AWS Messaging Module Best Practice/"}},{"fields":{"slug":"/Amazon SQS Deep Dive/"}},{"fields":{"slug":"/enabling_exactly_once_kafka_streams/"}},{"fields":{"slug":"/trasaction_in_kafka/"}},{"fields":{"slug":"/Exactly_Once_Semantics/"}},{"fields":{"slug":"/create/"}},{"fields":{"slug":"/struct/"}},{"fields":{"slug":"/behavior/"}},{"fields":{"slug":"/spring-autoconfigure/"}},{"fields":{"slug":"/ch7/"}},{"fields":{"slug":"/ch6/"}},{"fields":{"slug":"/ch5/"}},{"fields":{"slug":"/ch4/"}},{"fields":{"slug":"/ch3/"}},{"fields":{"slug":"/ch2/"}},{"fields":{"slug":"/ch1/"}},{"fields":{"slug":"/ch8/"}},{"fields":{"slug":"/ch7/"}},{"fields":{"slug":"/ch6/"}},{"fields":{"slug":"/ch5/"}},{"fields":{"slug":"/ch4/"}},{"fields":{"slug":"/ch3/"}},{"fields":{"slug":"/ch2/"}},{"fields":{"slug":"/ch1/"}}]}},"pageContext":{"skip":40,"totalPage":5,"currentPage":5}},"staticQueryHashes":[],"slicesMap":{}}