{"componentChunkName":"component---src-templates-post-jsx","path":"/java-synchronized/","result":{"data":{"site":{"siteMetadata":{"title":"SOOLAB"}},"markdownRemark":{"id":"7bca9259-d5b7-52e1-94c1-55705e11ef98","excerpt":"메모리 아키텍처 최신 하드웨어에서의 동시 프로그래밍은 동일한 물리적 순간에 서로 다른 코어에서 여러 스레드를 동시해 실행할 수 있다.\n아래 그림2에서 이를 확인할 수 있다.\n 각 CPU는 자체 레지스터를 포함하고 있는데, 이는 CPU 내부의 메모리로 간주된다. 레지스터에 접근하고 여기에 있는 변수들에 연산을 수행하는 것은 매우 빠르다.\nCPU는 캐시 메모…","html":"<h2 id=\"메모리-아키텍처\" style=\"position:relative;\">메모리 아키텍처<a href=\"#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98\" aria-label=\"메모리 아키텍처 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>최신 하드웨어에서의 동시 프로그래밍은 동일한 물리적 순간에 서로 다른 코어에서 여러 스레드를 동시해 실행할 수 있다.\n아래 [그림2]에서 이를 확인할 수 있다.\n<figure class='gatsby-resp-image-figure' style='margin-bottom: 16px;'>\n    <span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 553px; '>\n      <a class='gatsby-resp-image-link' href='/static/1b637c4d3ea573bb279d1579a5fbf417/d35da/img_1.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 91.1764705882353%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAAAsTAAALEwEAmpwYAAACjklEQVR42qVT2W7aUBT0/39L/iCtoiY0SqWWPYGQ2EDByHgD7wvY0zPXmFLaqg+90nDuMmfOhrW6cFDHL6iTmeD1ChMc0w1qNKtOl8Kd/IEnvvEzjsUeWp0aqP2PqHcdwT0qQb17UGfs7lDsn1GdFOuwq+74Vl1xa+8WRWyKYCZR9w9A9ITSvcd8dINke6fOCDooAsngJFhFo4Ybf0G4+QBjeCPnz0D4pJIpEqsRPPodZP4IsdNDYHUROX11PniPKEXwnGE0ROk/IfGGiOyGm7gD4Q6F+wmlEkx15E4Hruui1/+GwbCH8XgE23ERWY84hJclf0XqDbBem+j2vmIw6GL2NoPvbpFatyil39oxcxC7Y7ibV9jrF6yMPmxzAsecIrRHyCPzPJQyXiCwG661GmMtXGczlfNUqpPsMw5F2FUF1adafqIoarJp7/FzVac7ruPxiDiOm3t5aO81ioRhgP1+j91uB9M0lQ2CQNrgIM/zs+DhcBBe8+b7HjbCpR/BljGIVol0GIZYLBfQDQOGoWM6ncp+DsuylHO76OB5nrzpmC8WeJP+TYS7Wq8VN01TaCTyMJ8bWAjJMBq7XC7F4U0Fu8xw9X0lYnPFmRuNJXRdR1EUjWBZlsiyTIHltnuiaptzWmwBkSSJKpX7LM2UmOohy2Dk1ra9aMFglyCHQSjk+74aZOvLe411syxOjGBUWk77r4gby/62fjxTR2PqPNASDEDLclkGMynK4rxXJcrbJZegKAOoDC8F+ZDnmRrK9HWGd5nk82QiAzDwrr/J19THerNBLqLk/lOwjczh2LYNT3q63W7lU7Theq66Y1sus/tFsN1c9+kyepr87nzNZ/8YSPWQk+XE/gf8w1P4B88kV9LXMnU4AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='[그림2] 메모리 아키텍처' title='' src='/static/1b637c4d3ea573bb279d1579a5fbf417/d35da/img_1.png' srcset='/static/1b637c4d3ea573bb279d1579a5fbf417/e7570/img_1.png 170w,\n/static/1b637c4d3ea573bb279d1579a5fbf417/f46e7/img_1.png 340w,\n/static/1b637c4d3ea573bb279d1579a5fbf417/d35da/img_1.png 553w' sizes='(max-width: 553px) 100vw, 553px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy' decoding='async'>\n  </a>\n    </span>\n    <figcaption class='gatsby-resp-image-figcaption'>[그림2] 메모리 아키텍처</figcaption>\n  </figure></p>\n<p>각 CPU는 자체 레지스터를 포함하고 있는데, 이는 CPU 내부의 메모리로 간주된다. 레지스터에 접근하고 여기에 있는 변수들에 연산을 수행하는 것은 매우 빠르다.\nCPU는 캐시 메모리 계층을 가지고 있으며, 이 캐시 메모리에 빠르게 접근할 수 있다. 그러나 캐시 메모리의 접근 속도는 레지스터만큼 빠르지는 않다.</p>\n<p>모든 CPU는 메인 메모리에 접근할 수 있다. 메인 메모리는 CPU의 캐시 메모리보다 훨씬 크다.\nCPU가 메모리에서 무언가를 읽을 필요가 있을 때, 그것을 CPU의 캐시 메모리로 읽어들이고 연산을 수행한다.\nCPU는 레지스터로도 데이터를 읽어들일 수 있다. CPU가 메모리에 데이터를 다시 쓸 필요가 있을 때, 레지스터를 캐시 메모리로 플러시하고 결국 이 캐시 메모리는 메인 메모리로 플러시된다.</p>\n<p>일반적으로 플러시는 CPU가 다른 정보를 위한 공간을 만들 필요가 있을 때 수행된다. 따라서 이 플러시가 언제 일어날지에 대해서는 어떠한 가정도 할 수 없다.</p>\n<h2 id=\"Memory-Visiblity\" style=\"position:relative;\">Memory Visiblity<a href=\"#Memory-Visiblity\" aria-label=\"Memory Visiblity permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>메모리 가시성(Memory Visiblity)이란, 한 스레드에서 변경한 메모리 값이 다른 스레드에서도 동일한 값을 읽을 수 있는지라고 볼 수 있다.\n아래 코드는 가시성 문제가 발생할 수 있는 예제 코드이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Volatile</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">boolean</span> stopRequested<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">Thread</span> backgroundThread <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>stopRequested<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        backgroundThread<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        stopRequested <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 코드를 메인 스레드와 backgroundThread가 각각 다른 CPU 코어에 할당되어 실행되는 경우, 프로그램이 영원히 종료되지 않을 수 있다. 메모리 아키텍처의 특성상, 메인 스레드가 stopRequested 플래그를 true로 설정하더라도 이 변경은 메인 스레드가 할당된 코어의 캐시 메모리에만 저장될 수 있다. 결과적으로, backgroundThread는 메인 스레드에서 이루어진 이 변경을 감지하지 못할 수 있다. 이러한 현상을 가시성 문제라고 부른다.</p>\n<h2 id=\"synchronized-의미\" style=\"position:relative;\">synchronized 의미<a href=\"#synchronized-%EC%9D%98%EB%AF%B8\" aria-label=\"synchronized 의미 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>synchronized 키워드는 특정 코드 블록이나 메서드에 적용할 수 있다. 특정 코드 블록이나 메서드에 들어가지 전에 스레드가 적절한 잠금을 획득해야한 다는 것을 의미한다. 한번에 하나의 스레드만 synchronized 블록을 진행할 수 있으며, 다른 스레드는 잠금을 획득할 때 까지 진입하지 못한다.</p>\n<p>메서드에 붙인 synchronized 키워드는 객체 인스턴스에 속한 잠금을 획득해야 한다. 만약 메서드가 정적 메서드라면 클래스 객체에 속한 잠금을 획득해야 한다. 코드 블록에 synchronized 키워드를 사용하면 어떤 객체를 사용하여 잠금을 획득할지 명시해야 한다.</p>\n<p>잠금을 획득한 후, synchronized 블록에 진입하면, 블록 내에서 이루어진 모든 변경사항은 메인 메모리로 플러쉬된다.\n다른 스레드가 이후에 같은 객체의 synchronized 블록에 진입하면, 메인 메모리에서 객체의 최신 상태를 읽는다.</p>\n<p>따라서, synchronized 는 잠금뿐만 아니라 동기화를 수행하는데, 동기화의 의미는 특정 객체에 대한 메모리 표현이 다른 스레드 간에 일관되게 유지된다는 것으로 해석할 수 있다.</p>\n<h2 id=\"synchronized-특징\" style=\"position:relative;\">synchronized 특징<a href=\"#synchronized-%ED%8A%B9%EC%A7%95\" aria-label=\"synchronized 특징 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>아래는 synchronized 키워드의 그 외 대표적인 특징들이다.</p>\n<ul>\n<li>객체만 잠금 가능: 자바에서는 기본 데이터 타입(primitives)이 아닌 객체(Object)만 잠금이 가능하다.</li>\n<li>객체 배열의 잠금: 객체의 배열을 잠그는 것은 배열 내의 개별 객체들을 잠그는 것이 아니다.</li>\n<li>동기화된 메소드: synchronized 메소드는 전체 메소드를 포함하는 synchronized (this){...} 블록과 동등하다.(바이트 코드 레벨에서는 다르게 나타난다.)</li>\n<li>정적 synchronized 메소드: static synchronized 메소드는 클래스 객체(Class object)를 잠근다.</li>\n<li>클래스 객체의 잠금: 클래스 객체를 잠그는 경우, getClass()는 런타임 클래스에 대한 잠금, MyClass.class에 대한 잠금은 컴파일 시점에 결정된다.</li>\n<li>Inner 클래스의 동기화: Inner 클래스에서의 동기화는 outer 클래스와 독립적이다.</li>\n<li>인터페이스의 메소드 선언과 synchronized: synchronized는 메소드 시그니처가 아니므로 인터페이스에 선언할 수 없다.</li>\n<li>비동기화 메소드: 비동기화 메소드는 잠금의 상태를 고려하지 않으며, 동기화 메소드가 실행되는 동안에도 진행될 수 있다.</li>\n<li>재진입 가능한 잠금: 이미 잠금을 보유하고 있는 스레드가 동일한 잠금에 대한 synchronized 잠금을 만나면 계속해서 진행할 수 있다.</li>\n</ul>\n<h2 id=\"volatile\" style=\"position:relative;\">volatile<a href=\"#volatile\" aria-label=\"volatile permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>volatile 필드에 대한 값은 스레드에 의해 사용되기 전에 항상 메인 메모리에서 읽는다. 그리고, 스레드가 작성한 값은 항상 메인 메모리로 플러시된다.\nvolatile과 synchronized의 차이는 synchronized는 배타적인 잠금을 사용하여 한 번에 하나의 스레드만 synchronized 블록을 실행할 수 있도록 보장하는 반면에, volatile는 잠금을 사용하지 않는다.</p>\n<p>volatile 변수는 상태 의존적인 작업에 적합하지 않다. 예를 들어, <code class=\"language-text\">x = x + 1</code> 같은 연산은 x의 현재 값을 읽고, 그 값을 수정하여 다시 x에 저장하는 non-atomic 연산이다.\n이는 x의 값을 읽는 사이에 다른 스레드가 x를 수정할 수 있으며, 이는 race condition을 일으킬 수 있기 때문에 안전하지 않다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">Volatile</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">volatile</span> <span class=\"token keyword\">boolean</span> stopRequested<span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">InterruptedException</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token class-name\">Thread</span> backgroundThread <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">int</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>stopRequested<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                i<span class=\"token operator\">++</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        backgroundThread<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">sleep</span><span class=\"token punctuation\">(</span><span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        stopRequested <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>volatile로 선언된 stopRequested 플래그는 메인 스레드에서 값을 true로 변경하게 되면 이후에 발생하는 모든 해당 변수에 대한 후속 읽기는 항상 최신의 값을 읽는다는 것을 보장한다. </p>\n<h2 id=\"참조\" style=\"position:relative;\">참조<a href=\"#%EC%B0%B8%EC%A1%B0\" aria-label=\"참조 permalink\" class=\"anchor-header after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li><a href=\"https://dev.to/rnowif/what-is-a-volatile-variable-in-java-35ef\">https://dev.to/rnowif/what-is-a-volatile-variable-in-java-35ef</a></li>\n<li><a href=\"https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html\">https://docs.oracle.com/javase/specs/jls/se8/html/jls-17.html</a></li>\n</ul>","frontmatter":{"title":"자바의 synchronized와 volatile","date":"December 02, 2023","update":"December 20, 2023","tags":["Java"],"series":null},"fields":{"slug":"/java-synchronized/","readingTime":{"minutes":8.77}}},"seriesList":{"edges":[{"node":{"id":"88b7d66f-cc60-5ee2-b460-75fbac6dbe4d","fields":{"slug":"/ch1/"},"frontmatter":{"title":"1장 - 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션"}}},{"node":{"id":"edecb27b-7cba-5b3e-baf3-6af625f63e1d","fields":{"slug":"/ch2/"},"frontmatter":{"title":"2장 - 데이터 모델과 질의 언어"}}},{"node":{"id":"bd90f7b0-129a-5a48-83b4-aa86d5a05f22","fields":{"slug":"/ch3/"},"frontmatter":{"title":"3장 - 저장소와 검색"}}},{"node":{"id":"7ba45be6-b244-5f56-9992-79b670f5e4da","fields":{"slug":"/ch4/"},"frontmatter":{"title":"4장 - 부호화와 발전"}}},{"node":{"id":"5576af8a-c3e0-5e41-81eb-b7d04bdde4f5","fields":{"slug":"/ch5/"},"frontmatter":{"title":"5장 - 복제"}}},{"node":{"id":"27267918-cdd1-54a8-af0f-baad40da41fe","fields":{"slug":"/ch6/"},"frontmatter":{"title":"6장 - 파티셔닝"}}},{"node":{"id":"9db7e0fe-092b-509d-8114-216a230d82af","fields":{"slug":"/ch7/"},"frontmatter":{"title":"7장 - 트랜잭션"}}},{"node":{"id":"295cc398-6c96-56e5-a80e-1682afe45ffd","fields":{"slug":"/ch8/"},"frontmatter":{"title":"8장 - 분산 시스템의 골칫거리"}}},{"node":{"id":"a262dc65-d419-54eb-8a31-8471eb8afd19","fields":{"slug":"/ch1/"},"frontmatter":{"title":"1부 - 성능 기초"}}},{"node":{"id":"51344158-2351-53e1-9ab1-d6f79a451641","fields":{"slug":"/ch2/"},"frontmatter":{"title":"2부 - 성능 개선"}}},{"node":{"id":"3992b5fb-9aae-54ad-b626-d39c07ccc9ae","fields":{"slug":"/ch3/"},"frontmatter":{"title":"3부 - 화면 응답시간 분석"}}},{"node":{"id":"b8843120-0501-5e78-928d-08c1ed9db65c","fields":{"slug":"/ch4/"},"frontmatter":{"title":"4부 - 프로세스 이해하기"}}},{"node":{"id":"5dfe03b4-bedb-5f66-8969-240260c232e8","fields":{"slug":"/ch5/"},"frontmatter":{"title":"5부 - 소스코드 최적화"}}},{"node":{"id":"9815200b-4377-57d4-bcb8-9336c5f9b3b8","fields":{"slug":"/ch6/"},"frontmatter":{"title":"6부 - SQL 최적화"}}},{"node":{"id":"2c95f1eb-6875-5a65-b8ac-a715b9041713","fields":{"slug":"/ch7/"},"frontmatter":{"title":"7부 - 애플리케이션 입장에서의 SQL 튜닝"}}},{"node":{"id":"e3c9bd99-dddc-5d1b-bb33-56d3b61c299c","fields":{"slug":"/spring-autoconfigure/"},"frontmatter":{"title":"SpringBoot AutoConfiguration 시작하기"}}},{"node":{"id":"11a9d138-5dd0-5837-bdad-70aa4de33bcd","fields":{"slug":"/behavior/"},"frontmatter":{"title":"디자인 패턴 - 행동 패턴"}}},{"node":{"id":"eb3c0497-183a-5764-b158-2cbfc02069b8","fields":{"slug":"/struct/"},"frontmatter":{"title":"디자인 패턴 - 구조 패턴"}}},{"node":{"id":"62679b67-d124-5650-9e8c-10da079021ff","fields":{"slug":"/create/"},"frontmatter":{"title":"디자인 패턴 - 생성 패턴"}}},{"node":{"id":"34e2000f-4f63-5480-9c0d-aefcca9de23f","fields":{"slug":"/Exactly_Once_Semantics/"},"frontmatter":{"title":"카프카는 어떻게 Exactly-Once Semantics 보장하나?"}}},{"node":{"id":"07f3f0af-35df-5c6d-b6c9-7620523cb06d","fields":{"slug":"/trasaction_in_kafka/"},"frontmatter":{"title":"카프카에서의 Transactions"}}},{"node":{"id":"405d7847-99e0-5d6f-a07b-7ecd3016d705","fields":{"slug":"/enabling_exactly_once_kafka_streams/"},"frontmatter":{"title":"카프카 스트림즈의 정확히 한 번"}}},{"node":{"id":"33d16cf7-b112-593f-bd62-a51d0e3cb4b6","fields":{"slug":"/Amazon SQS Deep Dive/"},"frontmatter":{"title":"Amazon SQS 딥다이브"}}},{"node":{"id":"977791be-de20-5581-ac6b-7b777e8fe1cb","fields":{"slug":"/Spring Cloud AWS Messaging Module Best Practice/"},"frontmatter":{"title":"Spring Cloud AWS Messaging 모듈 문제점 및 튜닝"}}},{"node":{"id":"dde4af86-2501-59f6-ab69-71148e4d9d97","fields":{"slug":"/java-collection-wrapper/"},"frontmatter":{"title":"Collection Wrapper 클래스를 이용한 Service 계층 리팩토링 "}}},{"node":{"id":"77da0f76-df1e-529b-a46d-602987f6068d","fields":{"slug":"/spring-cache-hierarchy/"},"frontmatter":{"title":"Spring Cache 로 캐시 계층 구조 사용하기"}}},{"node":{"id":"b5b851d9-faec-54c9-bbbf-fb4035150e86","fields":{"slug":"/redis-event-notifications/"},"frontmatter":{"title":"Redis Keyspace Notifications에 대해 알아보자"}}},{"node":{"id":"221f8608-fceb-597e-b8a6-a72dfaa2efd9","fields":{"slug":"/jpa-slow-cause/"},"frontmatter":{"title":"JPA가 느릴 수 밖에 없는 원초적인 이유"}}},{"node":{"id":"e0bd02eb-2f80-54e3-a49c-74668400c523","fields":{"slug":"/ehcache3/"},"frontmatter":{"title":"Ehcache3 캐시 라이브러리 소개 (with Spring Boot)"}}},{"node":{"id":"93433e2f-6e6a-555e-b74e-c1a9e9af5bc4","fields":{"slug":"/mysql-primary-key-design/"},"frontmatter":{"title":"고성능을 위한 MySQL Primary Key 설계 전략"}}},{"node":{"id":"fdd87794-c713-57e2-ab09-d66190a14578","fields":{"slug":"/tomcat/"},"frontmatter":{"title":"Apache Tomcat 이해하기(NIO Connector 중심)"}}},{"node":{"id":"761f8e01-6f44-5d7f-87c0-f7177cba0d57","fields":{"slug":"/socket_option/"},"frontmatter":{"title":"Java의 Socket Option 정리"}}},{"node":{"id":"974e1e90-e20e-5b0e-8414-5c695ff4e24a","fields":{"slug":"/tomcat-connection/"},"frontmatter":{"title":"Tomcat은 어떻게 Connection을 관리할까?"}}},{"node":{"id":"dcb19b23-2230-57a7-8520-288cb92b91bd","fields":{"slug":"/spring-core-container/"},"frontmatter":{"title":"스프링으로 알아보는 IoC 컨테이너의 원리와 이해"}}},{"node":{"id":"db3f2384-1942-5aec-ac4d-844ced9303e1","fields":{"slug":"/socket_internal/"},"frontmatter":{"title":"요청이 급증하는 상황의 Connection reset by peer 트러블 슈팅"}}},{"node":{"id":"e4f37066-c670-5ed3-a373-ac02f6def2fc","fields":{"slug":"/mysql-transaction-lock/"},"frontmatter":{"title":"MySQL 잠금과 트랜잭션 Deep Dive"}}},{"node":{"id":"7bca9259-d5b7-52e1-94c1-55705e11ef98","fields":{"slug":"/java-synchronized/"},"frontmatter":{"title":"자바의 synchronized와 volatile"}}}]},"previous":{"fields":{"slug":"/mysql-transaction-lock/"},"frontmatter":{"title":"MySQL 잠금과 트랜잭션 Deep Dive"}},"next":null},"pageContext":{"id":"7bca9259-d5b7-52e1-94c1-55705e11ef98","series":null,"previousPostId":"e4f37066-c670-5ed3-a373-ac02f6def2fc","nextPostId":null}},"staticQueryHashes":[],"slicesMap":{}}